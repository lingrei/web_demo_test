<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Soundwave - MVP V25.0 (Visual & Logic Refine)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        /* --- 基础样式 --- */
        :root { --bg-color: #1e1e1e; --panel-color: #2d2d2d; --highlight: #4caf50; --text-color: #eee; --gold-color: #ffd700; --cpu-used: #ff9800; --item-blue: #64b5f6; --border: 1px solid #444; --playhead-color: #ff5252; --lose-color: #ff5252; }
        :root { --c-score: #ffd700; --c-support: #00e5ff; --c-engine: #d500f9; --c-neg: #ff5252; }
        :root { --kw-strong: #ff6b6b; --kw-weak: #4ecdc4; --kw-sync: #a29bfe; --kw-track: #74b9ff; --kw-empty: #ffeaa7; --kw-consume: #fd79a8; }

        body { background-color: var(--bg-color); color: var(--text-color); font-family: 'Segoe UI', sans-serif; margin: 0; height: 100vh; display: flex; justify-content: center; align-items: center; overflow: hidden; user-select: none; }
        
        .container { width: 98vw; max-width: 1600px; height: 95vh; display: grid; grid-template-columns: 200px 1fr 240px; grid-template-rows: 60px 1fr 210px; gap: 6px; background: #252525; padding: 8px; box-shadow: 0 0 50px rgba(0,0,0,0.8); border-radius: 8px; }
        
        /* Header */
        .header { grid-column: 1 / -1; grid-row: 1 / 2; background: var(--panel-color); border: var(--border); border-radius: 4px; display: flex; align-items: center; justify-content: space-between; padding: 0 20px; position: relative; }
        .header-left { display: flex; gap: 8px; flex: 1; } 
        .btn-icon { border: none; padding: 6px 12px; font-size: 11px; font-weight: bold; border-radius: 4px; cursor: pointer; display: flex; align-items: center; gap: 5px; transition: background 0.2s; white-space: nowrap; color: white; background: #444; }
        .btn-icon:hover { background: #555; }
        .btn-clear { background: #d32f2f; } .btn-clear:hover { background: #ef5350; }
        
        .header-center { flex: 2; display: flex; justify-content: center; align-items: center; }
        .stat-block-cpu { display: flex; flex-direction: column; align-items: center; width: 100%; max-width: 500px; }
        .cpu-label-row { display: flex; justify-content: space-between; width: 100%; margin-bottom: 4px; font-size: 12px; color: #ccc; font-weight: bold; padding: 0 5px; }
        .lbl-cpu-title { color: #4caf50; letter-spacing: 1px; text-transform: uppercase; }
        
        .cpu-track { width: 100%; height: 24px; background: #111; border-radius: 12px; overflow: hidden; border: 2px solid #555; box-shadow: inset 0 2px 8px rgba(0,0,0,0.6); position: relative; }
        .cpu-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #66bb6a, #a5d6a7); position: absolute; left: 0; top: 0; z-index: 1; transition: width 0.2s; }
        .cpu-fill.danger { background: linear-gradient(90deg, #ef5350, #e57373); }
        .cpu-fill.overload { background: #ff5252 !important; box-shadow: 0 0 20px #ff5252; animation: pulse-fast 0.15s infinite alternate; }

        .cpu-preview { height: 100%; position: absolute; top: 0; z-index: 2; display: none; }
        .cpu-preview.valid { background-color: #ffd700; box-shadow: 0 0 15px #ffd700; animation: pulse-slow 0.8s infinite ease-in-out; }
        .cpu-preview.invalid { background-color: #ff5252; box-shadow: 0 0 20px #ff5252; animation: pulse-fast 0.15s infinite alternate; }

        @keyframes pulse-slow { 0% { opacity: 0.3; } 50% { opacity: 0.9; } 100% { opacity: 0.3; } }
        @keyframes pulse-fast { 0% { opacity: 0.5; } 100% { opacity: 1; } }

        .header-right { flex: 1; display: flex; justify-content: flex-end; align-items: center; gap: 20px; }
        .stat-block-target { display: flex; flex-direction: column; align-items: flex-end; background: #222; padding: 5px 15px; border-radius: 6px; border: 1px solid #444; min-width: 100px; }
        .stat-label-target { font-size: 10px; color: #888; text-transform: uppercase; letter-spacing: 1px; }
        .stat-val-target { font-size: 22px; font-weight: bold; color: #fff; text-shadow: 0 0 5px rgba(255,255,255,0.1); }

        .debug-panel { display: flex; gap: 4px; align-items: center; opacity: 0.3; transition: opacity 0.2s; }
        .debug-panel:hover { opacity: 1; }
        .debug-input { width: 40px; background: #333; color: white; border: 1px solid #555; padding: 2px; font-size: 10px; text-align: center; }
        .debug-btn { background: #555; color: white; border: none; padding: 2px 6px; font-size: 10px; cursor: pointer; }

        /* Panels */
        .inventory-panel { grid-column: 1 / 2; grid-row: 2 / 3; background: var(--panel-color); border: var(--border); display: flex; flex-direction: column; overflow: hidden; }
        .panel-header { background: #222; padding: 10px 15px; font-weight: bold; text-align: center; border-bottom: var(--border); font-size: 13px; text-transform: uppercase; display: flex; justify-content: space-between; align-items: center; }
        .inventory-list { flex: 1; padding: 8px; overflow-y: auto; display: flex; flex-direction: column; gap: 6px; }
        .inv-item { background: #444; padding: 6px 8px; border-radius: 4px; cursor: grab; border: 1px solid transparent; transition: all 0.2s; border-left-width: 4px; position: relative; }
        .inv-item:hover { background: #505050; } 
        .inv-item:active { cursor: grabbing; }
        .inv-item.selected { background: #2e4e30; box-shadow: 0 0 8px var(--highlight); border-color: var(--highlight); }
        .inv-item.disabled { opacity: 0.3; pointer-events: none; filter: grayscale(1); }
        .inv-item b { display: block; margin-bottom: 2px; font-size: 12px; }
        .inv-meta { font-size: 10px; color: #aaa; display: flex; justify-content: space-between; }
        
        .daw-container { grid-column: 2 / 3; grid-row: 2 / 3; display: flex; flex-direction: column; background: #151515; border: var(--border); padding: 5px; height: 100%; box-sizing: border-box; }
        .timeline-header { display: flex; height: 20px; border-bottom: 1px solid #444; margin-bottom: 0; flex-shrink: 0; }
        .ruler-beat { flex: 1; border-right: 1px solid #333; font-size: 10px; color: #666; padding-left: 4px; line-height: 20px; }
        
        /* Track Area */
        .track-area { flex: 1; display: flex; flex-direction: column; gap: 0; border: 1px solid #333; height: 100%; position: relative; overflow: hidden; }
        .combat-overlay { position: absolute; top:0; left:0; width:100%; height:100%; pointer-events: none; z-index: 100; }
        
        .track { 
            flex: 1; 
            background: #1a1a1a; 
            border-bottom: 1px solid #333; 
            display: flex; 
            position: relative; 
            align-items: center; 
            transition: background-color 0.3s; 
        }
        .track:last-child { border-bottom: none; }
        
        /* Lock States */
        .track.hard-locked { 
            background: repeating-linear-gradient(45deg, #0a0a0a, #0a0a0a 10px, #181818 10px, #181818 20px) !important; 
            opacity: 0.4; pointer-events: none; filter: grayscale(1); 
            border: 2px dashed #333 !important;
        }
        .track.hard-locked .grid-cell {
            background: transparent !important;
            border-color: #222 !important;
        }
        .track-lock-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 50; display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.3s; border: 2px dashed #444;
        }
        .lock-icon { font-size: 24px; color: #888; transition: all 0.2s; }
        .track-lock-overlay:hover .lock-icon { color: white; transform: scale(1.2); }
        .track-lock-overlay.shake-hint .lock-icon { animation: shake-lock 2s infinite; color: var(--gold-color); text-shadow: 0 0 10px var(--gold-color); }
        @keyframes shake-lock { 0% { transform: rotate(0deg); } 10% { transform: rotate(-10deg); } 20% { transform: rotate(10deg); } 30% { transform: rotate(-10deg); } 40% { transform: rotate(10deg); } 50% { transform: rotate(0deg); } 100% { transform: rotate(0deg); } }
        
        .track-lock-overlay.unlocking { animation: lock-break 0.6s forwards; }
        @keyframes lock-break { 
            0% { opacity: 1; background-color: rgba(255,255,255,0.2); } 
            50% { transform: scale(1.05); background-color: rgba(255,255,255,0.5); opacity: 0.8; } 
            100% { transform: scale(1.1); opacity: 0; display: none; } 
        }

        .grid-cell { 
            flex: 1; height: 100%; 
            border-right: 1px solid #2a2a2a; 
            transition: background-color 0.3s; 
        }
        .grid-cell:nth-child(4n) { border-right: 1px solid #444; } 
        .grid-cell:nth-child(16n) { border-right: 1px solid #666; }
        .grid-cell.cell-strong { background-color: rgba(0, 0, 0, 0.4); } 
        .grid-cell.cell-weak { background-color: rgba(255, 255, 255, 0.02); }

        .flash-weak-fix { animation: flash-gold 0.5s; }
        @keyframes flash-gold { 0% { background-color: rgba(255,215,0,0.5); } 100% { background-color: transparent; } }
        .flash-track-purple { animation: flash-purple 0.5s; }
        @keyframes flash-purple { 0% { background-color: rgba(213,0,249,0.3); } 100% { background-color: #1a1a1a; } }

        .track-area.dragging-mode .track:not(.locked) { background-color: #222; }
        .track-area.dragging-mode .grid-cell.cell-strong { background-color: rgba(255, 255, 255, 0.05); }
        .track-area.dragging-mode .grid-cell.cell-weak { background-color: rgba(255, 255, 255, 0.08); }

        .playhead { position: absolute; top: 0; bottom: 0; left: 0; width: 2px; background-color: var(--playhead-color); z-index: 9999; box-shadow: 0 0 10px var(--playhead-color); pointer-events: none; display: none; }
        
        .placed-item { position: absolute; height: 50%; background: var(--item-blue); border-radius: 3px; display: flex; align-items: center; justify-content: center; font-size: 11px; color: black; font-weight: bold; box-shadow: 0 2px 5px rgba(0,0,0,0.5); border: 2px solid rgba(255,255,255,0.2); cursor: grab; transition: transform 0.1s; z-index: 5; overflow: hidden; white-space: nowrap; }
        .placed-item:hover { filter: brightness(1.1); z-index: 6; }
        .placed-item:active { cursor: grabbing; z-index: 20; }
        .placed-item.selected-placed { border-color: white; z-index: 20; transform: scale(1.02); }
        .placed-item.playing-active { filter: brightness(2.5) contrast(1.5) !important; box-shadow: 0 0 30px white !important; z-index: 50 !important; transform: scale(1.1); }
        
        .placed-item.glowing-score { box-shadow: inset 0 0 10px var(--c-score); border: 2px solid var(--c-score); background-color: rgba(255,215,0,0.3) !important; }
        .placed-item.glowing-support { box-shadow: inset 0 0 10px var(--c-support); border: 2px solid var(--c-support); background-color: rgba(0,229,255,0.3) !important; }
        .placed-item.glowing-engine { box-shadow: inset 0 0 10px var(--c-engine); border: 2px solid var(--c-engine); background-color: rgba(213,0,249,0.3) !important; }
        
        /* Support item refined glow states */
        /* State 1: Has buff targets (score items being buffed) - Soft cyan */
        .placed-item.glowing-support-buff { 
            box-shadow: 0 0 12px rgba(0, 229, 255, 0.6), inset 0 0 8px rgba(0, 229, 255, 0.3); 
            border: 2px solid rgba(0, 229, 255, 0.7); 
            background-color: rgba(0, 229, 255, 0.15) !important; 
        }
        /* State 2: Triggered own extra effect - Deep blue */
        .placed-item.glowing-support-effect { 
            box-shadow: 0 0 12px rgba(30, 144, 255, 0.7), inset 0 0 10px rgba(30, 144, 255, 0.4); 
            border: 2px solid #1e90ff; 
            background-color: rgba(30, 144, 255, 0.25) !important; 
        }
        /* State 3: Perfect - Both buff targets AND extra effect - Vibrant gradient glow */
        .placed-item.glowing-support-perfect { 
            box-shadow: 0 0 20px rgba(0, 255, 200, 0.8), 0 0 40px rgba(0, 229, 255, 0.4), inset 0 0 15px rgba(0, 255, 255, 0.5); 
            border: 3px solid #00ffcc; 
            background: linear-gradient(135deg, rgba(0, 229, 255, 0.4), rgba(0, 255, 200, 0.35)) !important; 
            animation: support-perfect-pulse 1.2s ease-in-out infinite; 
        }
        @keyframes support-perfect-pulse { 
            0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 200, 0.8), 0 0 40px rgba(0, 229, 255, 0.4), inset 0 0 15px rgba(0, 255, 255, 0.5); } 
            50% { box-shadow: 0 0 30px rgba(0, 255, 200, 1), 0 0 50px rgba(0, 229, 255, 0.6), inset 0 0 20px rgba(0, 255, 255, 0.7); } 
        }

        /* Engine Effects */
        .engine-aura { position: absolute; background: rgba(213,0,249,0.25); border: 2px solid #d500f9; box-shadow: 0 0 15px #d500f9; z-index: 40; pointer-events: none; border-radius: 4px; animation: aura-pulse 2s infinite; }
        @keyframes aura-pulse { 0% { opacity: 0.5; transform: scale(1); } 50% { opacity: 0.8; transform: scale(1.05); } 100% { opacity: 0.5; transform: scale(1); } }

        .shop-panel { grid-column: 3 / 4; grid-row: 2 / 3; background: var(--panel-color); border: var(--border); display: flex; flex-direction: column; transition: all 0.3s; position: relative; }
        .shop-panel.drag-target-sell { background-color: rgba(244, 67, 54, 0.2); border: 2px dashed #f44336; }
        .shop-panel.sell-hint { border-color: rgba(244, 67, 54, 0.5); background-color: rgba(244, 67, 54, 0.05); box-shadow: inset 0 0 15px rgba(244, 67, 54, 0.1); }

        .shop-list { flex: 1; padding: 4px; overflow-y: auto; display: flex; flex-direction: column; gap: 4px; }
        .shop-item { background: #222; padding: 5px 6px; border: 1px solid #444; border-radius: 3px; display: flex; flex-direction: column; gap: 2px; cursor: pointer; transition: all 0.2s; position: relative; }
        .shop-item:hover { background: #2a2a2a; border-color: #555; }
        .shop-item.owned-unique { opacity: 0.5; pointer-events: none; filter: grayscale(1); border-color: #555; }
        .discount-tag { position: absolute; top: -4px; right: -4px; background: #f44336; color: white; font-size: 8px; padding: 1px 3px; border-radius: 2px; font-weight: bold; transform: rotate(15deg); }
        .shop-row-top { display: flex; justify-content: space-between; align-items: center; }
        .shop-row-top b { font-size: 11px; }
        .shop-row-btm { display: flex; justify-content: space-between; align-items: center; font-size: 9px; color: #888; }
        .shop-price-row { display: flex; justify-content: space-between; align-items: center; border-top: 1px solid #333; padding-top: 4px; margin-top: 2px; }
        .shop-price { color: var(--gold-color); font-weight: bold; font-size: 11px; }
        .btn-buy { background: linear-gradient(135deg, var(--highlight) 0%, #388e3c 100%); border: none; color: white; cursor: pointer; padding: 4px 10px; border-radius: 3px; font-size: 10px; font-weight: bold; transition: all 0.2s; }
        .btn-buy:hover { transform: scale(1.03); box-shadow: 0 0 6px rgba(76,175,80,0.5); }
        .btn-buy:disabled { background: #444 !important; color: #666 !important; cursor: not-allowed; transform: none; box-shadow: none; }
        
        .shop-controls { padding: 10px; border-top: 1px solid #444; display: flex; flex-direction: column; gap: 10px; background: #252525; }
        .btn-cpu { width: 100%; padding: 12px; background: linear-gradient(135deg, #1e88e5, #42a5f5); border: 1px solid #64b5f6; color: white; cursor: pointer; font-weight: bold; border-radius: 6px; display: flex; flex-direction: column; align-items: center; line-height: 1.2; box-shadow: 0 4px 6px rgba(0,0,0,0.3); text-transform: uppercase; letter-spacing: 1px; transition: all 0.2s; }
        .btn-cpu:hover { transform: translateY(-1px); box-shadow: 0 6px 10px rgba(0,0,0,0.4); filter: brightness(1.1); }
        .btn-cpu:active { transform: translateY(1px); box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        .btn-cpu:disabled { background: #444; border-color: #555; color: #aaa; cursor: not-allowed; box-shadow: none; transform: none; }
        .btn-reroll { width: 100%; background: #444; color: #ddd; border: 1px solid #555; padding: 8px; cursor: pointer; font-weight: bold; font-size: 11px; border-radius: 4px; transition: background 0.2s; }
        .btn-reroll:hover { background: #555; color: white; }
        .shop-funds { color: var(--gold-color); font-size: 16px; font-weight: bold; text-shadow: 0 0 5px rgba(255, 215, 0, 0.3); }

        .bottom-panel { grid-column: 1 / -1; grid-row: 3 / 4; display: flex; gap: 10px; padding-top: 5px; position: relative; overflow: hidden; }
        .info-box { background: var(--panel-color); border: var(--border); padding: 12px 15px; border-radius: 4px; overflow-y: auto; transition: filter 0.3s; }
        .info-left { flex: 2.5; border-left: 4px solid var(--highlight); } 
        .info-right { flex: 1; display: flex; flex-direction: column; justify-content: space-between; border-left: 4px solid #ffd700; padding-left: 15px; }
        .target-display { background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%); border: 2px solid #ffd700; border-radius: 6px; padding: 8px 12px; text-align: center; }
        .target-label { font-size: 10px; color: #ffd700; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 2px; }
        .target-value { font-size: 26px; font-weight: bold; color: #fff; text-shadow: 0 0 10px rgba(255,215,0,0.3); }
        .detail-title { font-size: 17px; color: white; margin-bottom: 5px; font-weight: bold; display: flex; align-items: center; gap: 5px; }
        .detail-meta { font-size: 13px; color: #aaa; margin-bottom: 6px; display: flex; gap: 15px; }
        .detail-desc { font-size: 14px; color: #ddd; line-height: 1.5; background: #222; padding: 10px; border-radius: 5px; }
        
        .action-row { display: flex; gap: 10px; margin-top: 5px; }
        .submit-btn { flex: 2; padding: 10px; background: white; color: black; font-size: 18px; font-weight: bold; border: none; border-radius: 20px; cursor: pointer; transition: transform 0.1s; }
        .submit-btn:hover { transform: scale(1.02); box-shadow: 0 0 15px white; }
        .submit-btn:disabled { background: #555; color: #888; transform: none; box-shadow: none; cursor: wait; }
        
        .sim-btn { flex: 1; padding: 10px; background: #444; color: #aaa; font-size: 12px; font-weight: bold; border: 1px solid #555; border-radius: 10px; cursor: pointer; transition: all 0.2s; display: flex; flex-direction: column; align-items: center; justify-content: center; line-height: 1.1; }
        .sim-btn:hover:not(:disabled) { background: #555; color: white; border-color: #666; }
        .sim-btn b { color: var(--gold-color); font-size: 14px; }

        .drag-ghost { position: fixed; pointer-events: none; z-index: 9999; opacity: 0.9; box-shadow: 0 10px 20px rgba(0,0,0,0.5); border: 2px solid white; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold; color: black; white-space: nowrap; overflow: hidden; transform: translate(-50%, -50%); }
        .drag-preview-valid { background-color: rgba(76, 175, 80, 0.4) !important; border: 2px dashed #4caf50; z-index: 10; pointer-events: none; }
        .drag-preview-invalid { background-color: rgba(244, 67, 54, 0.3) !important; border: 2px dashed #f44336; z-index: 10; pointer-events: none; }
        .item-being-dragged { opacity: 0.4; filter: grayscale(1); }
        .skip-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(211, 47, 47, 0.9); color: white; display: none; justify-content: center; align-items: center; cursor: pointer; z-index: 100; font-weight: bold; font-size: 24px; }
        .drag-sell-tooltip { position: fixed; z-index: 10000; background: #222; border: 2px solid gold; padding: 5px 10px; border-radius: 6px; font-weight: bold; font-size: 14px; color: gold; box-shadow: 0 0 15px rgba(255, 215, 0, 0.5); pointer-events: none; transform: translate(15px, -15px); }

        .tooltip-ref { color: #4fc3f7; font-weight: bold; cursor: help; border-bottom: 1px dashed #4fc3f7; position: relative; }
        #tooltip { position: fixed; background: #111; border: 1px solid #666; padding: 8px; border-radius: 4px; color: #eee; font-size: 12px; z-index: 9999; display: none; box-shadow: 0 4px 10px rgba(0,0,0,0.5); max-width: 250px; pointer-events: none; }
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 9999; display: none; justify-content: center; align-items: center; }
        .modal-content { background: #333; padding: 30px; border-radius: 8px; width: 900px; max-height: 90vh; overflow-y: auto; box-shadow: 0 0 30px black; text-align: center; position: relative; }
        
        .btn-large-option { width: 45%; padding: 15px; font-size: 16px; border-radius: 8px; border: none; cursor: pointer; font-weight: bold; margin: 0 10px; transition: all 0.2s; color: white; background: #444; border: 1px solid #555; }
        .btn-large-option:hover { background: #555; transform: scale(1.05); }
        .btn-confirm { background: #4caf50; border-color: #4caf50; }
        .btn-confirm:hover { background: #43a047; }


        .floating-text { position: fixed; font-weight: bold; pointer-events: none; z-index: 10001; animation: float-anim 1.5s forwards; text-shadow: 0 2px 2px rgba(0,0,0,0.8); white-space: nowrap; font-size: 24px; }
        .ft-score { color: #ffd700; font-size: 32px; }
        .ft-buff { color: #00e5ff; font-size: 20px; }
        .ft-active { color: #76ff03; font-size: 18px; }
        .ft-perfect { color: #ff4081; font-size: 28px; text-shadow: 0 0 10px #ff4081, 0 2px 4px rgba(0,0,0,0.8); }
        .ft-neg { color: #ff5252; font-size: 20px; }
        @keyframes float-anim { 0% { opacity: 0; transform: translateY(0) scale(0.5); } 10% { opacity: 1; transform: translateY(-20px) scale(1.2); } 100% { opacity: 0; transform: translateY(-60px) scale(1); } }
        
        /* Support item perfect trigger glow */
        .support-perfect { animation: perfect-glow 0.8s ease-out; }
        @keyframes perfect-glow { 
            0% { box-shadow: 0 0 20px #ff4081, 0 0 40px #ff4081; transform: scale(1.15); } 
            100% { box-shadow: 0 0 5px rgba(255,64,129,0.3); transform: scale(1); } 
        }
        
        /* RESULT GRID 2.0 */
        .result-daw-container { position: relative; background: #111; padding: 10px; border-radius: 4px; border: 1px solid #444; margin: 20px 0; overflow: hidden; }
        .res-grid-row { display: flex; height: 40px; margin-bottom: 15px; position: relative; border: 1px solid #333; }
        .res-grid-bg { position: absolute; top:0; left:0; width:100%; height:100%; display: flex; z-index: 0; pointer-events: none; }
        .res-grid-cell { flex: 1; border-right: 1px solid #2a2a2a; }
        .res-grid-cell:nth-child(4n) { border-right: 1px solid #444; }
        
        .res-item { position: absolute; height: 100%; border-radius: 3px; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: bold; color: #111; cursor: help; border: 2px solid rgba(255,255,255,0.1); transition: all 0.2s; z-index: 10; }
        .res-item:hover { z-index: 15; transform: scale(1.05); border-color: white; box-shadow: 0 0 15px rgba(255,255,255,0.3); }
        .res-item.highlight-source { border-color: #00e5ff; box-shadow: 0 0 15px #00e5ff; z-index: 12; }
        .res-item.highlight-target { border-color: #d500f9; box-shadow: 0 0 15px #d500f9; z-index: 12; }
        .res-connections { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 20; }
        
        @keyframes guide-pulse-gentle { 0% { box-shadow: inset 0 0 2px rgba(255,215,0,0.2); border-color: rgba(255,215,0,0.3); } 50% { box-shadow: inset 0 0 12px rgba(255,215,0,0.6); border-color: rgba(255,215,0,0.9); } 100% { box-shadow: inset 0 0 2px rgba(255,215,0,0.2); border-color: rgba(255,215,0,0.3); } }
        .soft-guide-gentle { position: relative; z-index: 900; border: 2px solid gold !important; animation: guide-pulse-gentle 3s infinite ease-in-out; }
        .soft-guide { border: 2px solid gold !important; animation: guide-pulse-strong 2s infinite ease-in-out; }
        @keyframes guide-pulse-strong { 0% { box-shadow: 0 0 3px rgba(255,215,0,0.4); } 50% { box-shadow: 0 0 15px rgba(255,215,0,0.9); } 100% { box-shadow: 0 0 3px rgba(255,215,0,0.4); } }
        
        .result-tooltip { position: fixed; background: rgba(0,0,0,0.95); border: 1px solid #666; padding: 10px; border-radius: 4px; color: #fff; z-index: 20000; pointer-events: none; text-align: left; font-size: 12px; min-width: 200px; box-shadow: 0 5px 20px black; }
        .rt-row { display: flex; justify-content: space-between; margin-bottom: 2px; }
        .rt-formula { border-top: 1px solid #444; margin-top: 5px; padding-top: 5px; color: #aaa; font-style: italic; font-size: 11px; text-align: center; }
        .rt-total { margin-top: 5px; font-weight: bold; color: gold; font-size: 14px; text-align: center; }
        
        .status-hearts.shake { animation: shake 0.5s; display: inline-block; color: #ff5252; }
        @keyframes shake { 0% { transform: translate(1px, 1px) rotate(0deg); } 10% { transform: translate(-1px, -2px) rotate(-1deg); } 20% { transform: translate(-3px, 0px) rotate(1deg); } 30% { transform: translate(3px, 2px) rotate(0deg); } 40% { transform: translate(1px, -1px) rotate(1deg); } 50% { transform: translate(-1px, 2px) rotate(-1deg); } 60% { transform: translate(-3px, 1px) rotate(0deg); } 70% { transform: translate(3px, 1px) rotate(-1deg); } 80% { transform: translate(-1px, -1px) rotate(1deg); } 90% { transform: translate(1px, 2px) rotate(0deg); } 100% { transform: translate(1px, -2px) rotate(-1deg); } }
        
        .float-text { position: fixed; pointer-events: none; z-index: 9999; font-weight: bold; font-size: 16px; animation: float-up 1s forwards; }
        @keyframes float-up { 0% { opacity: 1; transform: translateY(0); } 100% { opacity: 0; transform: translateY(-30px); } }
        
        /* Unlock Anim */
        .unlock-flash-anim { animation: unlock-pop 0.5s ease-out; background-color: #333 !important; opacity: 1 !important; }
        @keyframes unlock-pop { 0% { background-color: white; transform: scale(1.05); } 100% { background-color: #333; transform: scale(1); } }
        
        /* === STRONG GUIDE SYSTEM === */
        .guide-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 8000; display: none; }
        .guide-highlight { position: relative; z-index: 8500 !important; box-shadow: 0 0 0 4px #ffd700, 0 0 30px rgba(255,215,0,0.5) !important; animation: guide-glow 1.5s infinite; }
        @keyframes guide-glow { 0% { box-shadow: 0 0 0 4px #ffd700, 0 0 30px rgba(255,215,0,0.5); } 50% { box-shadow: 0 0 0 6px #ffd700, 0 0 50px rgba(255,215,0,0.8); } 100% { box-shadow: 0 0 0 4px #ffd700, 0 0 30px rgba(255,215,0,0.5); } }
        .guide-message { position: fixed; z-index: 9000; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border: 2px solid #ffd700; border-radius: 12px; padding: 20px 30px; max-width: 450px; text-align: center; box-shadow: 0 10px 40px rgba(0,0,0,0.8), 0 0 20px rgba(255,215,0,0.3); }
        .guide-message h3 { color: #ffd700; margin: 0 0 12px 0; font-size: 18px; }
        .guide-message p { color: #ddd; margin: 0 0 16px 0; font-size: 15px; line-height: 1.5; }
        .guide-message .guide-btn { background: linear-gradient(135deg, #ffd700 0%, #ffaa00 100%); color: #000; border: none; padding: 10px 30px; font-size: 14px; font-weight: bold; border-radius: 6px; cursor: pointer; transition: all 0.2s; }
        .guide-message .guide-btn:hover { transform: scale(1.05); box-shadow: 0 0 15px rgba(255,215,0,0.6); }
        .guide-message .guide-skip { background: transparent; color: #888; border: 1px solid #555; margin-left: 10px; }
        .guide-message .guide-skip:hover { color: #fff; border-color: #888; }
        .guide-arrow { position: absolute; width: 0; height: 0; }
        .guide-arrow.arrow-up { border-left: 12px solid transparent; border-right: 12px solid transparent; border-bottom: 12px solid #ffd700; top: -12px; }
        .guide-arrow.arrow-down { border-left: 12px solid transparent; border-right: 12px solid transparent; border-top: 12px solid #ffd700; bottom: -12px; }
        .guide-arrow.arrow-left { border-top: 12px solid transparent; border-bottom: 12px solid transparent; border-right: 12px solid #ffd700; left: -12px; }
        .guide-arrow.arrow-right { border-top: 12px solid transparent; border-bottom: 12px solid transparent; border-left: 12px solid #ffd700; right: -12px; }
        
        /* === PERFORMANCE STAGE V26.2 === */
        .performance-stage {
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: 10000;
            display: none;
            overflow: hidden;
            background: #000; /* Black background to hide main UI */
        }
        .performance-stage.active { display: flex; justify-content: center; align-items: center; }
        
        /* Stage wrapper maintains aspect ratio */
        .stage-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 177.78vh; /* 16:9 aspect ratio */
            max-height: 56.25vw;
        }
        
        .stage-bg {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            transition: opacity 0.3s ease;
        }
        .stage-bg.hidden { opacity: 0; }
        
        /* Heart layer - covers full stage, positioned to match background */
        .stage-heart-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
        }
        
        /* Heart container - uses same sizing as background */
        .stage-heart-container {
            position: absolute;
            width: 100%; height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
        }
        .stage-heart-container img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            object-position: center;
        }
        .stage-heart-container.pulse-tiny { animation: heartPulseTiny 0.12s ease-out; }
        .stage-heart-container.pulse-small { animation: heartPulseSmall 0.15s ease-out; }
        .stage-heart-container.pulse-medium { animation: heartPulseMedium 0.2s ease-out; }
        .stage-heart-container.pulse-large { animation: heartPulseLarge 0.25s ease-out; }
        .stage-heart-container.pulse-huge { animation: heartPulseHuge 0.3s ease-out; }
        
        @keyframes heartPulseTiny { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.01); } }
        @keyframes heartPulseSmall { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.02); } }
        @keyframes heartPulseMedium { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.04); } }
        @keyframes heartPulseLarge { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.07); } }
        @keyframes heartPulseHuge { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.12); } }
        
        /* Score display in heart center */
        .heart-score-display {
            position: absolute;
            top: 42%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #fff;
            text-shadow: 0 0 20px rgba(0,0,0,0.9), 0 2px 6px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 10004;
        }
        .heart-score-label {
            font-size: clamp(12px, 1.5vw, 20px);
            color: #ffcccc;
            text-transform: uppercase;
            letter-spacing: 3px;
            margin-bottom: 5px;
        }
        .heart-score-value {
            font-size: clamp(36px, 5vw, 72px);
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 30px rgba(255,100,100,0.8), 0 0 60px rgba(255,50,50,0.4);
        }
        
        /* Floating score text */
        .stage-float-score {
            position: absolute;
            font-weight: bold;
            pointer-events: none;
            z-index: 10005;
            animation: stageFloatUp 1.2s ease-out forwards;
            text-shadow: 0 2px 6px rgba(0,0,0,0.9);
        }
        .stage-float-score.score { color: #ffd700; font-size: clamp(18px, 2.5vw, 36px); }
        .stage-float-score.buff { color: #00e5ff; font-size: clamp(14px, 2vw, 28px); }
        
        @keyframes stageFloatUp {
            0% { opacity: 0; transform: translateY(0) scale(0.5); }
            15% { opacity: 1; transform: translateY(-20px) scale(1.2); }
            100% { opacity: 0; transform: translateY(-60px) scale(1); }
        }
        
        /* Computer screen area for DAW - positioned relative to stage */
        .stage-computer-screen {
            position: absolute;
            background: rgba(0,0,0,0.95);
            border: 3px solid #444;
            border-radius: 6px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }
        
        .stage-daw-container {
            width: 100%; height: 100%;
            position: relative;
        }
        
        .stage-track {
            position: absolute;
            left: 0; right: 0;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
        }
        .stage-track:last-child { border-bottom: none; }
        
        .stage-grid-cell {
            position: absolute;
            top: 0; height: 100%;
            border-right: 1px solid #2a2a2a;
        }
        .stage-grid-cell:nth-child(4n) { border-right-color: #444; }
        .stage-grid-cell.cell-strong { background-color: rgba(0,0,0,0.4); }
        
        .stage-placed-item {
            position: absolute;
            height: 60%;
            top: 20%;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(8px, 0.8vw, 12px);
            color: #000;
            font-weight: bold;
            border: 2px solid rgba(255,255,255,0.3);
            transition: filter 0.1s, box-shadow 0.1s;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .stage-placed-item.playing-active {
            filter: brightness(2) contrast(1.3);
            box-shadow: 0 0 20px white, 0 0 40px rgba(255,255,255,0.5);
            animation: stageItemPulse 0.3s ease-out;
        }
        @keyframes stageItemPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.15); }
            100% { transform: scale(1); }
        }
        
        /* Floating score text for stage DAW */
        .stage-daw-float {
            position: absolute;
            font-weight: bold;
            color: #ffd700;
            font-size: 14px;
            pointer-events: none;
            z-index: 200;
            animation: stageDawFloat 0.8s ease-out forwards;
            text-shadow: 0 0 8px rgba(255,200,0,0.8), 0 2px 4px rgba(0,0,0,0.8);
        }
        .stage-daw-float.buff {
            color: #00ffcc;
            text-shadow: 0 0 8px rgba(0,255,200,0.8), 0 2px 4px rgba(0,0,0,0.8);
        }
        @keyframes stageDawFloat {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-25px) scale(1.2); }
        }
        
        /* Connection beam for stage DAW */
        .stage-daw-beam {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, transparent, #00ffcc, #00ffcc, transparent);
            opacity: 0.8;
            pointer-events: none;
            z-index: 50;
            transform-origin: left center;
            animation: stageBeamFade 0.6s ease-out forwards;
        }
        @keyframes stageBeamFade {
            0% { opacity: 0.8; }
            100% { opacity: 0; }
        }
        
        .stage-playhead {
            position: absolute;
            top: 0; bottom: 0;
            left: 0;
            width: 3px;
            background: #ff5252;
            box-shadow: 0 0 15px #ff5252;
            z-index: 100;
        }
        
        /* Energy beam/ray effects */
        .stage-beam {
            position: absolute;
            pointer-events: none;
            z-index: 10003;
        }
        .stage-beam-head {
            position: absolute;
            width: 12px; height: 12px;
            background: radial-gradient(circle, #fff 0%, #00ffcc 50%, transparent 80%);
            border-radius: 50%;
            box-shadow: 0 0 15px #00ffcc, 0 0 30px rgba(0,255,200,0.8);
            transform: translate(-50%, -50%);
        }
        .stage-beam-trail {
            position: absolute;
            height: 4px;
            background: linear-gradient(90deg, transparent 0%, rgba(0,255,200,0.8) 30%, #00ffcc 100%);
            border-radius: 2px;
            transform-origin: right center;
            box-shadow: 0 0 8px rgba(0,255,200,0.5);
        }
        
        /* Settlement screen V26.1 */
        .settlement-screen {
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: 10010;
            display: none;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
        }
        .settlement-screen.active { display: flex; }
        
        .settlement-bg {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-size: cover;
            background-position: center;
            filter: blur(8px) brightness(0.3);
        }
        
        .settlement-content {
            position: relative;
            z-index: 1;
            display: flex;
            gap: 30px;
            align-items: stretch;
            max-width: 1200px;
            max-height: 90vh;
            overflow: auto;
        }
        
        .settlement-left {
            display: flex;
            flex-direction: column;
            gap: 15px;
            flex: 1;
            min-width: 500px;
        }
        
        /* DAW Preview in Settlement - Full track display */
        .settlement-track-preview {
            background: #111;
            border: 2px solid #444;
            border-radius: 8px;
            padding: 15px;
            min-width: 500px;
            margin-top: 30px; /* Move down */
        }
        
        /* Settlement DAW Track display */
        .settle-daw-row {
            display: flex;
            height: 35px;
            margin-bottom: 8px;
            position: relative;
            border: 1px solid #333;
            background: #1a1a1a;
        }
        .settle-grid-bg {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            z-index: 0;
            pointer-events: none;
        }
        .settle-grid-cell {
            flex: 1;
            border-right: 1px solid #2a2a2a;
        }
        .settle-grid-cell:nth-child(4n) { border-right-color: #444; }
        .settle-item {
            position: absolute;
            height: 100%;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            color: #111;
            cursor: pointer;
            border: 2px solid rgba(255,255,255,0.2);
            z-index: 10;
            transition: all 0.2s;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding: 0 4px;
        }
        .settle-item:hover {
            z-index: 15;
            transform: scale(1.05);
            border-color: white;
            box-shadow: 0 0 15px rgba(255,255,255,0.3);
        }
        
        .settlement-stamp {
            position: relative;
            width: 220px;
            min-width: 220px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding-top: 20px;
        }
        
        .stamp-circle {
            width: 180px;
            height: 180px;
            border: 6px solid;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transform: rotate(-15deg);
            animation: stampDrop 0.5s ease-out;
            background: rgba(0,0,0,0.5);
        }
        .stamp-circle.victory { border-color: #4caf50; color: #4caf50; }
        .stamp-circle.failed { border-color: #f44336; color: #f44336; }
        
        @keyframes stampDrop {
            0% { transform: rotate(-15deg) scale(2); opacity: 0; }
            60% { transform: rotate(-15deg) scale(0.9); opacity: 1; }
            100% { transform: rotate(-15deg) scale(1); opacity: 1; }
        }
        
        .stamp-score {
            font-size: 32px;
            font-weight: bold;
        }
        .stamp-label {
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .settlement-right {
            display: flex;
            flex-direction: column;
            gap: 12px;
            color: #fff;
            min-width: 200px;
        }
        
        .settlement-stars {
            display: flex;
            gap: 8px;
            font-size: 28px;
            justify-content: center;
            margin-bottom: 10px;
        }
        .settlement-star { color: #333; }
        .settlement-star.earned { color: #ffd700; text-shadow: 0 0 10px rgba(255,215,0,0.5); }
        
        /* Rewards section */
        .settlement-rewards {
            background: rgba(0,0,0,0.6);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #444;
        }
        .settlement-rewards-title {
            font-size: 14px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 10px;
            letter-spacing: 1px;
        }
        .reward-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            border-bottom: 1px solid #333;
        }
        .reward-row:last-child { border-bottom: none; }
        .reward-label { color: #aaa; font-size: 13px; }
        .reward-value { font-weight: bold; font-size: 16px; }
        .reward-value.gold { color: #ffd700; }
        .reward-value.cpu { color: #4fc3f7; }
        .reward-value.item { color: #d500f9; }
        
        /* Milestone progress */
        .milestone-container {
            background: rgba(213,0,249,0.1);
            border: 1px solid #d500f9;
            border-radius: 6px;
            padding: 10px;
            margin-top: 5px;
        }
        .milestone-label {
            font-size: 11px;
            color: #d500f9;
            margin-bottom: 5px;
        }
        .milestone-bar {
            height: 8px;
            background: #222;
            border-radius: 4px;
            overflow: hidden;
        }
        .milestone-fill {
            height: 100%;
            background: linear-gradient(90deg, #d500f9, #ff4081);
            transition: width 0.5s;
        }
        
        .settlement-stat {
            background: rgba(0,0,0,0.6);
            padding: 12px 15px;
            border-radius: 8px;
            border: 1px solid #444;
        }
        
        .settlement-stat-label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 3px;
        }
        
        .settlement-stat-value {
            font-size: 22px;
            font-weight: bold;
        }
        .settlement-stat-value.gold { color: #ffd700; }
        .settlement-stat-value.cpu { color: #4fc3f7; }
        
        .settlement-stat-change {
            font-size: 14px;
            margin-left: 8px;
        }
        .settlement-stat-change.positive { color: #4caf50; }
        
        .settlement-stars {
            display: flex;
            gap: 10px;
            font-size: 32px;
        }
        .settlement-star { color: #333; }
        .settlement-star.earned { color: #ffd700; text-shadow: 0 0 10px rgba(255,215,0,0.5); }
        
        .settlement-progress {
            display: flex;
            gap: 8px;
        }
        .progress-dot {
            width: 20px; height: 20px;
            border-radius: 50%;
            background: #333;
            border: 2px solid #555;
        }
        .progress-dot.done { background: #4caf50; border-color: #4caf50; }
        .progress-dot.current { background: #ffd700; border-color: #ffd700; }
        
        .settlement-btn {
            padding: 15px 40px;
            font-size: 18px;
            font-weight: bold;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 20px;
        }
        .settlement-btn.next { background: #4caf50; color: #fff; }
        .settlement-btn.next:hover { background: #43a047; transform: scale(1.05); }
        .settlement-btn.retry { background: #f44336; color: #fff; }
        .settlement-btn.retry:hover { background: #e53935; transform: scale(1.05); }
    </style>
</head>
<body>

<!-- Performance Stage V26.1 - Responsive -->
<div class="performance-stage" id="performanceStage">
    <div class="stage-wrapper" id="stageWrapper">
        <!-- Background layers for expression switching -->
        <div class="stage-bg" id="stageBgNeutral" style="background-image: url('bg_neutral.png');"></div>
        <div class="stage-bg hidden" id="stageBgHappy" style="background-image: url('bg_happy.png');"></div>
        <div class="stage-bg hidden" id="stageBgAngry" style="background-image: url('bg_angry.png');"></div>
        
        <!-- Heart UI layer - overlays background at same position -->
        <div class="stage-heart-container" id="stageHeartContainer">
            <img src="heart_big.png" id="stageHeartImg">
        </div>
        
        <!-- Score display in heart center -->
        <div class="heart-score-display" id="heartScoreDisplay">
            <div class="heart-score-label" id="heartScoreLabel">Total Groove</div>
            <div class="heart-score-value" id="heartScoreValue">0</div>
        </div>
        
        <!-- Computer screen for DAW playback -->
        <div class="stage-computer-screen" id="stageComputerScreen">
            <div class="stage-daw-container" id="stageDawContainer">
                <div class="stage-playhead" id="stagePlayhead"></div>
            </div>
        </div>
        
        <!-- Particle container -->
        <div id="stageParticleContainer"></div>
    </div>
</div>

<!-- Settlement Screen V26.1 -->
<div class="settlement-screen" id="settlementScreen">
    <div class="settlement-bg" id="settlementBg"></div>
    <div class="settlement-content">
        <div class="settlement-left">
            <div class="settlement-track-preview" id="settlementTrackPreview">
                <!-- DAW tracks rendered here -->
            </div>
        </div>
        <div class="settlement-stamp">
            <div class="stamp-circle" id="stampCircle">
                <div class="stamp-score" id="stampScore">0</div>
                <div class="stamp-label" id="stampLabel">VICTORY</div>
            </div>
        </div>
        <div class="settlement-right">
            <div class="settlement-stars" id="settlementStars">
                <span class="settlement-star">★</span>
                <span class="settlement-star">★</span>
                <span class="settlement-star">★</span>
            </div>
            <div class="settlement-rewards" id="settlementRewards">
                <div class="settlement-rewards-title" id="lblRewardsTitle">REWARDS</div>
                <div id="rewardsList">
                    <!-- Rewards rendered here -->
                </div>
                <div class="milestone-container" id="milestoneContainer" style="display:none;">
                    <div class="milestone-label" id="milestoneLabel">Rare Item Progress: 0/2</div>
                    <div class="milestone-bar">
                        <div class="milestone-fill" id="milestoneFill" style="width:0%"></div>
                    </div>
                </div>
            </div>
            <div class="settlement-stat">
                <div class="settlement-stat-label" id="lblSettleProgress">PROGRESS</div>
                <div class="settlement-progress" id="settleProgress"></div>
            </div>
            <button class="settlement-btn next" id="settlementNextBtn" onclick="settlementNext()">NEXT</button>
        </div>
    </div>
</div>

<div id="tooltip"></div>
<div id="resultTooltip" class="result-tooltip" style="display:none;"></div>

<!-- Strong Guide System -->
<div class="guide-overlay" id="guideOverlay"></div>
<div class="guide-message" id="guideMessage" style="display:none;">
    <h3 id="guideTitle">Guide</h3>
    <p id="guideText">...</p>
    <div>
        <button class="guide-btn" id="guideBtn" onclick="advanceGuide()">OK</button>
    </div>
</div>

<div class="container" id="mainContainer">
    <div class="header">
        <div class="header-left">
            <button class="btn-icon btn-lang" onclick="toggleLanguage()">🌐 CN/EN</button>
            <button class="btn-icon btn-help" onclick="showHelpModal()">❓ HELP</button>
            <button class="btn-icon" onclick="showHistory()">📜 <span id="txtHistory">HISTORY</span></button>
            <button class="btn-icon btn-clear" onclick="clearAllItems()">🗑️ <span id="txtClear">CLEAR</span></button>
        </div>
        
        <div class="header-center">
            <div class="stat-block-cpu" id="cpuContainer">
                <div class="cpu-label-row">
                    <span class="lbl-cpu-title" id="lblCpu">★ CPU</span>
                    <span id="maxCpuText">Max: 12</span>
                </div>
                <div class="cpu-track">
                    <div class="cpu-fill" id="cpuBar"></div>
                    <div class="cpu-preview" id="cpuPreviewBar"></div>
                </div>
                <div class="cpu-label-row" style="margin-top: 2px;">
                    <span id="cpuText">0</span>
                </div>
            </div>
        </div>

        <div class="header-right">
            <div class="debug-panel">
                <input type="number" id="dbgGold" class="debug-input" placeholder="G">
                <button class="debug-btn" onclick="window.debugSetGold()">$</button>
                <input type="number" id="dbgTarget" class="debug-input" placeholder="Tgt">
                <button class="debug-btn" onclick="window.debugSetTarget()">T</button>
            </div>
        </div> 
    </div>

    <div class="inventory-panel" id="invPanel">
        <div class="panel-header" id="lblInventory">INVENTORY</div>
        <div class="inventory-list" id="inventoryList"></div>
    </div>

    <div class="daw-container">
        <div class="timeline-header"></div>
        <div class="track-area" id="trackArea">
            <svg id="combatConnections" class="combat-overlay"></svg>
        </div>
    </div>

    <div class="shop-panel" id="shopPanel">
        <div class="panel-header">
            <span id="lblShop">SHOP</span>
            <span class="shop-funds" id="goldText">150 G</span>
        </div>
        <div class="shop-list" id="shopList"></div>
        <div class="shop-controls">
            <button class="btn-cpu" onclick="buyCpu()" id="btnBuyCpu">
                <span id="txtUpCpu" style="font-size:14px;">UP CPU</span>
                <span style="font-size:11px; opacity:0.8; margin-top:2px;" id="cpuPriceText">50G</span>
            </button>
            <button class="btn-reroll" onclick="rerollShop()" id="btnReroll">REROLL (10G)</button>
        </div>
    </div>

    <div class="bottom-panel">
        <div id="skipOverlay" class="skip-overlay" onclick="skipPlayback()">⏩ CLICK TO FAST FORWARD</div>
        <div class="info-box info-left" id="detailPanel">
            <div class="detail-title" id="detailTitle">Ready</div>
            <div class="detail-meta" id="detailMeta"></div>
            <div class="detail-desc" id="detailContent">...</div>
        </div>
        <div class="info-box info-right" id="infoRight" style="padding:8px 12px;">
            <div class="target-display" id="targetContainer" style="padding:5px 10px;">
                <div class="target-label" id="lblTarget" style="font-size:9px; margin-bottom:1px;">TARGET GROOVE</div>
                <div class="target-value" id="targetText" style="font-size:22px;">360</div>
            </div>
            <div class="tier-display" id="tierContainer" style="display:none; margin-top:4px; font-size:11px; line-height:1.4;">
                <div style="display:flex; justify-content:space-between; padding:2px 0; border-bottom:1px solid #333;">
                    <span style="color:#76ff03;">★</span>
                    <span id="tier1Score" style="color:#76ff03;">360</span>
                </div>
                <div style="display:flex; justify-content:space-between; padding:2px 0; border-bottom:1px solid #333;">
                    <span style="color:#ffd700;">★★</span>
                    <span id="tier2Score" style="color:#ffd700;">396</span>
                </div>
                <div style="display:flex; justify-content:space-between; padding:2px 0;">
                    <span style="color:#ff4081;">★★★</span>
                    <span id="tier3Score" style="color:#ff4081;">450</span>
                </div>
            </div>
            <div style="font-size:12px; color:#aaa; line-height:1.4; margin:4px 0;">
                <span id="lblLevel">Level:</span> <span id="levelNum" style="color:#fff;">1</span> &nbsp;|&nbsp;
                <span id="lblTracks">Tracks:</span> <span id="trackNum" style="color:#fff;">2</span>
            </div>
            <div class="action-row" style="gap:6px;">
                <button class="sim-btn" id="simBtn" onclick="runSimulation()" style="padding:8px 12px;">
                    <span>SIMULATE</span>
                    <b id="simCostText">50G</b>
                </button>
                <button class="submit-btn" id="mainSubmitBtn" onclick="trySubmit()" style="padding:8px 16px;">SUBMIT</button>
            </div>
        </div>
    </div>
</div>

<div class="modal" id="startScreen" style="display:flex;">
    <div class="modal-content" style="width: 400px;">
        <h1>Soundwave</h1>
        <p style="color:#aaa; margin-bottom:30px;" id="txtStartMsg">Music Roguelike Deckbuilder</p>
        <button class="submit-btn" onclick="showLangSelect()" id="btnStartGame">START GAME</button>
    </div>
</div>

<div class="modal" id="langSelectModal">
    <div class="modal-content" style="width: 500px;">
        <h2 style="margin-bottom: 30px;">Select Language / 选择语言</h2>
        <div style="display:flex; justify-content: center;">
            <button class="btn-large-option" onclick="selectLang('en')">English</button>
            <button class="btn-large-option" onclick="selectLang('cn')">简体中文</button>
        </div>
    </div>
</div>

<div class="modal" id="tutorialQueryModal">
    <div class="modal-content" style="width: 500px;">
        <h2 id="lblTutTitle" style="margin-bottom: 10px;">Tutorial</h2>
        <p id="lblTutDesc" style="color:#aaa; margin-bottom: 30px;">Recommended for new players.</p>
        <div style="display:flex; justify-content: center;">
            <button class="btn-large-option" onclick="skipTutorial()" id="btnSkipTut">Skip</button>
            <button class="btn-large-option btn-confirm" onclick="playTutorial()" id="btnPlayTut">Play Tutorial</button>
        </div>
    </div>
</div>

<div class="modal" id="tutorialCompleteModal">
    <div class="modal-content" style="width: 550px;">
        <h2 style="color:var(--highlight);" id="lblTutCompTitle">Tutorial Complete!</h2>
        <p style="color:#aaa; margin-bottom:30px; white-space:pre-line; line-height:1.6;" id="lblTutCompDesc">You are now ready for the real challenge.</p>
        <button class="submit-btn" onclick="finishTutorialFlow()" id="btnEnterGame">ENTER GAME</button>
    </div>
</div>

<div class="modal" id="helpModal">
    <div class="modal-content" style="width: 600px; text-align: left;">
        <h2 style="text-align:center; color:var(--highlight);" id="lblHelpTitle">HOW TO PLAY</h2>
        <div class="help-section">
            <h3 id="lblHelpControl">CONTROLS</h3>
            <p id="txtHelpControl">...</p>
        </div>
        <button class="submit-btn" onclick="closeHelpModal()">GOT IT</button>
    </div>
</div>

<div class="modal" id="resultModal">
    <div class="modal-content" style="width: 1000px;">
        <h2 id="resTitle">DATA ANALYSIS</h2>
        <div id="campaignStatusContainer" class="campaign-status-modal"></div>
        
        <h3 id="resOutcome" style="font-size:28px; margin: 5px 0;"></h3>
        
        <div style="display:flex; justify-content:space-around; margin-bottom:10px;">
            <div><span id="lblResTarget">Target</span>: <span id="resTargetDisplay" style="font-size:24px;"></span></div>
            <div><span id="lblResTotal">Total</span>: <span id="resTotalScore" style="font-size:32px; color:gold; font-weight:bold;"></span></div>
        </div>

        <div class="result-daw-container" id="resGridContainer">
            <svg id="resConnections" class="res-connections"></svg>
            <div id="resTrackArea" style="position:relative;"></div>
        </div>

        <div id="resRewardInfo" style="text-align:center; color:#4caf50; font-weight:bold; margin:10px 0;"></div>
        <div style="margin-top:20px; display:flex; gap:20px; justify-content:center;">
            <button class="submit-btn" style="width:200px; display:none;" id="nextLevelBtn" onclick="nextLevel()">NEXT LEVEL</button>
            <button class="submit-btn" style="width:200px; display:none;" id="finishGameBtn" onclick="showVictory()">VICTORY</button>
            <button class="submit-btn" style="width:200px; display:none; background:#d32f2f;" id="retryLevelBtn" onclick="retryLevel()">RETRY</button>
            <button class="submit-btn" style="width:200px; display:none; background:#000;" id="dieBtn" onclick="showGameOver()">ACCEPT FATE</button>
            <button class="submit-btn" style="width:200px;" id="simCloseBtn" onclick="closeResult()">BACK</button>
        </div>
    </div>
</div>

<div class="modal" id="victoryModal">
    <div class="modal-content" style="width: 500px;">
        <h1 style="color:gold;" id="txtWinTitle">YOU WIN!</h1>
        <p id="txtWinMsg">You have completed all levels.</p>
        <button class="submit-btn" onclick="location.reload()" id="btnRestart1">PLAY AGAIN</button>
    </div>
</div>

<div class="modal" id="gameOverModal">
    <div class="modal-content" style="width: 500px;">
        <h1 style="color:#ff5252;" id="txtLoseTitle">GAME OVER</h1>
        <p id="txtLoseMsg">Ran out of lives.</p>
        <button class="submit-btn" onclick="location.reload()" id="btnRestart2">TRY AGAIN</button>
    </div>
</div>

<div class="modal" id="discordModal">
    <div class="modal-content" style="width: 450px; text-align: center;">
        <h2 style="color: #5865F2; margin-bottom: 10px;">🎮 Join Our Community!</h2>
        <p style="color: #aaa; margin-bottom: 20px;" id="txtDiscordMsg">Thanks for playing! Join our Discord to share feedback and connect with other players.</p>
        <div style="background: white; padding: 20px; border-radius: 12px; display: inline-block; margin-bottom: 20px;">
            <img src="discord_qr.png" alt="Discord QR Code" style="width: 200px; height: 200px; display: block;">
        </div>
        <p style="color: #888; font-size: 12px; margin-bottom: 15px;" id="txtScanQR">Scan to join Discord</p>
        <div style="display: flex; gap: 10px; justify-content: center;">
            <a href="https://discord.gg/XeJ6mfQtVW" target="_blank" class="submit-btn" style="text-decoration: none; display: inline-block; padding: 12px 24px; background: #5865F2;">
                <span id="txtJoinDiscord">Open Discord</span>
            </a>
            <button class="submit-btn" style="background: #444;" onclick="closeDiscordAndContinue()" id="btnDiscordContinue">Continue</button>
        </div>
    </div>
</div>

<div class="modal" id="confirmSubmitModal">
    <div class="modal-content" style="width: 420px; text-align: center;">
        <h2 style="color: #ff9800; margin-bottom: 15px;">⚠️ <span id="txtConfirmTitle">Confirm Submit</span></h2>
        <p style="color: #ddd; margin-bottom: 10px; font-size: 15px;" id="txtConfirmMsg">This action cannot be undone. If you fail, you will lose ALL progress and restart from Level 1.</p>
        <p style="color: #ff5252; margin-bottom: 20px; font-size: 14px;" id="txtConfirmWarning">Make sure your build is ready!</p>
        <div style="display: flex; gap: 12px; justify-content: center;">
            <button class="submit-btn" style="background: #444; padding: 12px 30px;" onclick="cancelSubmit()" id="btnCancelSubmit">Cancel</button>
            <button class="submit-btn" style="background: #ff5252; padding: 12px 30px;" onclick="confirmSubmit()" id="btnConfirmSubmit">Submit</button>
        </div>
    </div>
</div>

<div class="modal" id="simRequiredModal">
    <div class="modal-content" style="width: 450px; text-align: center;">
        <h2 style="color: #4caf50; margin-bottom: 15px;">💡 <span id="txtSimRequiredTitle">Simulate First</span></h2>
        <p style="color: #ddd; margin-bottom: 15px; font-size: 15px; line-height: 1.6;" id="txtSimRequiredMsg">Before submitting, you must simulate your build and achieve a score that meets or exceeds the target score.</p>
        <p style="color: #ffd700; margin-bottom: 20px; font-size: 14px;" id="txtSimRequiredWarning">Use the SIMULATE button to test your build!</p>
        <div style="display: flex; gap: 12px; justify-content: center;">
            <button class="submit-btn" style="background: #4caf50; padding: 12px 30px;" onclick="closeSimRequired()" id="btnSimRequiredOK">Got it</button>
        </div>
    </div>
</div>

<script>
    // --- Constants ---
    const TICKS = 32;
    const TOTAL_TRACKS = 3; 
    let TOTAL_DURATION = 16; 
    let TICK_DURATION = TOTAL_DURATION / TICKS;
    
    const AUDIO_SOURCES = {
        // === SIMPLIFIED BGM SYSTEM V26.0 ===
        // Tutorial mode: only down_DB_1
        // Standard mode: only down_DB_2
        bgm_tutorial: "down_DB_1.mp3",
        bgm_standard: "down_DB_2.mp3",
        
        // Item sounds - these are the main audio content players create
        SB1: "On_Beat_1.mp3", SB2: "On_Beat_2.mp3", SB3: "On_Beat_3.mp3", SB4: "On_Beat_4.mp3", SB5: "On_Beat_5.mp3",
        EB1: "Off_Beat_1.mp3", EB2: "Off_Beat_2.mp3", EB3: "Off_Beat_3.mp3", EB4: "Off_Beat_4.mp3", EB5: "Off_Beat_5.mp3", EB6: "Off_Beat_6.mp3",
        NG1: "exp_Beat_1.mp3", NG2: "exp_Beat_2.mp3", NG3: "exp_Beat_3.mp3", NG4: "exp_Beat_4.mp3",
        TUT1: "On_Beat_2.mp3", TUT2: "On_Beat_3.mp3"
    };

    const UI_TEXT = {
        en: {
            clear: "CLEAR", help: "HELP", history: "HISTORY", cpu: "★ CPU", target: "TARGET GROOVE", funds: "FUNDS (G)",
            inventory: "INVENTORY", shop: "SHOP", upCpu: "UP CPU", sell: "SELL", reroll: "REROLL",
            ready: "Ready", readyDesc: "<b>Drag & Drop</b> items from Inventory to Tracks.<br>Drag off-track to remove.<br>Drag to Shop to sell.",
            level: "Level:", tracks: "Tracks:", submit: "SUBMIT", simulate: "SIMULATE",
            startTitle: "Music Roguelike Deckbuilder", startGame: "START GAME",
            report: "DATA ANALYSIS", resTarget: "Target", resTotal: "Total",
            nextLevel: "NEXT LEVEL", victory: "VICTORY", retry: "RETRY", acceptFate: "ACCEPT FATE",
            youWin: "YOU WIN!", winMsg: "You have completed all levels.", playAgain: "PLAY AGAIN",
            gameOver: "GAME OVER", loseMsg: "You failed to reach the target. Back to Level 1.", tryAgain: "TRY AGAIN",
            confirmTitle: "Confirm Submit", confirmMsg: "This action cannot be undone. If you fail, you will lose ALL progress and restart from Level 1.", confirmWarning: "Make sure your build is ready!", confirmCancel: "Cancel", confirmSubmit: "Submit",
            purchased: "SOLD", outcomeWin: "SUCCESS", outcomeLose: "FAILED",
            reward: "Reward", consolation: "Consolation", ng1Charge: "NG1 Charge", stacks: "stacks",
            item: "Item", base: "Base", cond: "Cond", mult: "Mult", final: "Final", note: "Note", effect: "Effect", sold: "Sold",
            helpTitle: "HOW TO PLAY", helpControlTitle: "CONTROLS",
            helpControlTxt: "• <b>Drag Inventory -> Track</b>: Place Item<br>• <b>Drag Track -> Track</b>: Move Item<br>• <b>Drag Track -> Outside</b>: Remove Item (Refund CPU)<br>• <b>Drag Inventory -> Shop</b>: Sell Item<br>• <b>Right Click</b>: Quick Remove",
            tutTitle: "Tutorial", tutDesc: "Recommended for new players.", skip: "Skip", playTut: "Play Tutorial",
            tutComp: "Tutorial Complete!", tutCompDesc: "You are now ready for the real challenge.\n\n⚠️ WARNING: In the main game, failure is PERMANENT! If you don't reach the target score, you must restart from Level 1.", enterGame: "ENTER GAME",
            soldOutQAQ: "Sold Out QAQ", simReport: "SIMULATION REPORT",
            self: "Self Effect", global: "Global Rule",
            discordMsg: "Thanks for playing! Join our Discord to share feedback and connect with other players.",
            scanQR: "Scan to join Discord", joinDiscord: "Open Discord", discordContinue: "Continue"
        },
        cn: {
            clear: "清空", help: "帮助", history: "历史", cpu: "★ CPU", target: "目标 Groove", funds: "资金 (G)",
            inventory: "库存", shop: "商店", upCpu: "升级 CPU", sell: "出售", reroll: "刷新",
            ready: "准备就绪", readyDesc: "<b>操作指南:</b><br>• <b>拖拽</b>: 库存 -> 音轨 (放置)<br>• <b>拖拽</b>: 音轨 -> 音轨 (移动)<br>• <b>拖出</b>: 移出音轨 (移除)<br>• <b>拖拽至商店</b>: 出售道具",
            level: "当前关卡:", tracks: "轨道数量:", submit: "结算", simulate: "试听",
            startTitle: "音乐构筑 Roguelike MVP 演示", startGame: "开始游戏",
            report: "数据分析", resTarget: "目标", resTotal: "总分",
            nextLevel: "下一关", victory: "加冕时刻", retry: "重试", acceptFate: "接受结局",
            youWin: "恭喜通关!", winMsg: "你已经完成了所有挑战。", playAgain: "再次开始",
            gameOver: "游戏结束", loseMsg: "未能达到目标分数，回到第一关重新开始。", tryAgain: "重头再来",
            confirmTitle: "确认提交", confirmMsg: "此操作不可撤销。如果失败，你将失去所有进度，必须从第一关重新开始。", confirmWarning: "确保你的布局已经准备好了！", confirmCancel: "取消", confirmSubmit: "提交",
            purchased: "已购", outcomeWin: "挑战成功", outcomeLose: "挑战失败",
            reward: "赏金", consolation: "抚恤金", ng1Charge: "NG1 充能", stacks: "层",
            item: "道具", base: "基础", cond: "条件", mult: "倍率", final: "最终", note: "备注", effect: "效果", sold: "已售出",
            helpTitle: "玩法说明", helpControlTitle: "操作方式",
            helpControlTxt: "• <b>左键拖拽 (库存->音轨)</b>: 放置道具<br>• <b>左键拖拽 (音轨->音轨)</b>: 移动位置<br>• <b>拖拽至音轨外</b>: 移除道具 (返还CPU)<br>• <b>拖拽至商店区域</b>: 出售道具<br>• <b>右键点击</b>: 快速移除",
            tutTitle: "新手教程", tutDesc: "强烈建议新玩家游玩。", skip: "跳过", playTut: "进入教程",
            tutComp: "教程结束!", tutCompDesc: "恭喜完成！现在进入正式挑战。\n\n⚠️ 警告：在正式关卡中，失败是永久的！如果未能达到目标分数，你将必须从第一关重新开始。", enterGame: "进入正式关卡",
            soldOutQAQ: "商店卖断货了 QAQ", simReport: "模拟运行报告",
            self: "自身效果", global: "全局规则",
            discordMsg: "感谢游玩！扫码加入我们的Discord社区，分享反馈、与其他玩家交流！",
            scanQR: "扫码加入 Discord", joinDiscord: "打开 Discord", discordContinue: "继续"
        }
    };

    const DEFINITIONS = {
        en: { 
            "Strong Beat": "Dark grid area (Start of 1st and 3rd beat per bar).", 
            "Weak Beat": "Light grid area (2nd and 4th beat per bar).", 
            "Same Track": "Refers only to items on the same horizontal track.", 
            "Sync": "Other items triggered at the same time point (vertically).", 
            "Empty Slot": "Unoccupied grid cells with no items placed.", 
            "Empty Slots": "Unoccupied grid cells with no items placed.", 
            "Consume": "Reduce target item's score and use that amount for self calculation.",
            "Consumed": "Reduce target item's score and use that amount for self calculation."
        },
        cn: { 
            "强拍": "指深色网格区域（每小节第1、3拍）。", 
            "弱拍": "指浅色网格区域（每小节第2、4拍）。", 
            "同轨": "仅指处于同一水平音轨上的道具。", 
            "同步": "指在垂直方向上，与该道具在同一时间点被触发的其他道具。", 
            "空拍": "指未放置任何道具的空格子。", 
            "吞噬": "减少目标道具的分数，并将其作为自身分数的计算依据。"
        }
    };

    // Keyword colors defined in CSS: --kw-strong, --kw-weak, --kw-sync, --kw-track, --kw-empty, --kw-consume

    const DB = [
        { id: "SB1", name: {en: "Kick Drum", cn: "底鼓"}, desc: {en: "Gain 20 Groove on trigger.<br>If the Start Point is on a [Strong Beat], gain an additional 10 Groove.", cn: "触发时获得 20 Groove。<br>若起始点位于[强拍]，额外获得 10 Groove。"}, len: 4, cpu: 1, base: 20, type: "score", color: "#ffecb3", price: 100, rarity: 1 },
        { id: "SB2", name: {en: "Sidechain", cn: "侧链"}, desc: {en: "Increase Groove of all items [Sync] with self by +50%.<br>If the Start Point is on a [Strong Beat], increase this effect by an additional +25%.", cn: "使所有与自身[同步]的道具 Groove +50%。<br>若起始点位于[强拍]，该增幅额外 +25%。"}, len: 4, cpu: 1, base: 0, type: "support", color: "#b2ebf2", price: 75, rarity: 1 },
        { id: "SB3", name: {en: "Accent", cn: "重音标记"}, desc: {en: "Increase Groove of the Next item on [Same Track] by +100%.<br>If the Start Point is on a [Strong Beat], the Next item is forcibly treated as being triggered on a [Strong Beat].", cn: "[同轨]使下一个道具 Groove +100%。<br>若起始点位于[强拍]，下一个道具将被强制视为在[强拍]触发。"}, len: 4, cpu: 2, base: 0, type: "support", color: "#80deea", price: 100, rarity: 2 },
        { id: "SB4", name: {en: "Master Clock", cn: "主时钟"}, desc: {en: "Unique (Only one copy allowed).<br>Engine: If the Start Point is on a [Strong Beat], and at least 5 [Strong Beat] effects have triggered before this:<br>Multiply Groove of all subsequent [Strong Beat] items in this loop by 1.5x.", cn: "唯一，只能同时存在一个同名道具。<br>若起始点位于[强拍]，且触发前已触发至少 5次[强拍]效果：<br>本轮后续触发的所有[强拍]道具 Groove x 1.5。"}, len: 4, cpu: 4, base: 0, type: "engine", color: "#e1bee7", price: 150, rarity: 3, unique: true },
        { id: "SB5", name: {en: "Quantizer", cn: "量化器"}, desc: {en: "Unique (Only one copy allowed).<br>Engine: If the Start Point is on a [Strong Beat],<br>all [Weak Beat] on the field are treated as [Strong Beat].", cn: "唯一，只能同时存在一个同名道具。<br>若起始点位于[强拍]的起始点，全场所有的[弱拍]位置均被视为[强拍]。"}, len: 8, cpu: 4, base: 0, type: "engine", color: "#ce93d8", price: 150, rarity: 3, unique: true },
        { id: "EB1", name: {en: "Rest Note", cn: "休止符"}, desc: {en: "Gain 14 Groove on trigger.<br>If the Previous item on the [Same Track] is at least 4 [Empty Slots] away, gain an additional 20 Groove.", cn: "触发时获得 14 Groove。<br>若[同轨]前一个道具与自身间隔 ≥ 4个[空拍]，额外获得 20 Groove。"}, len: 2, cpu: 1, base: 14, type: "score", color: "#ffe082", price: 100, rarity: 1 },
        { id: "EB2", name: {en: "Pre-Delay", cn: "预延时"}, desc: {en: "Increase Groove of the Next item on the [Same Track] by +35%.<br>For every 1 [Empty Slot] between self and that item, increase this effect by an additional +12.5%.<br><b>Max Bonus: +125%</b>", cn: "使[同轨]下一个道具 Groove +35%。<br>自身与该道具每间隔 1个[空拍]，增幅效果额外 +12.5%。<br><b>上限：+125%</b>"}, len: 2, cpu: 1, base: 0, type: "support", color: "#4dd0e1", price: 100, rarity: 1 },
        { id: "EB3", name: {en: "Isolation Booth", cn: "隔离室"}, desc: {en: "Increase Groove of all items [Sync] with self by +10.<br>For every 1 [Empty Slot] between self and [Same Track] neighbors (Previous/Next), increase Groove of [Sync] items by +7.5%.<br><b>Max Bonus: +240%</b>", cn: "使所有与自身[同步]的道具 Groove +10。<br>自身与[同轨]前后道具每间隔 1个[空拍]，使[同步]道具 Groove +7.5%。<br><b>上限：+240%</b>"}, len: 4, cpu: 2, base: 0, type: "support", color: "#00bcd4", price: 100, rarity: 2 },
        { id: "EB4", name: {en: "Atmosphere", cn: "氛围采样"}, desc: {en: "Gain 30 Groove on trigger.<br>For every 1 [Empty Slot] that appeared before trigger, gain +5% Groove.", cn: "触发时获得 30 Groove。<br>触发前每出现 1个[空拍]，自身 Groove +5%。"}, len: 4, cpu: 3, base: 30, type: "score", color: "#ffd54f", price: 150, rarity: 3 },
        { id: "EB5", name: {en: "Time Stretch", cn: "时间拉伸"}, desc: {en: "Unique (Only one copy allowed).<br>Engine: In calculations after this item finishes triggering:<br>Every 1 [Empty Slot] counts as 2 [Empty Slots].", cn: "唯一，只能同时存在一个同名道具。<br>引擎：当该道具触发结束后的计算中：<br>每1个[空拍]将被视为 2个[空拍]。"}, len: 8, cpu: 4, base: 0, type: "engine", color: "#ba68c8", price: 150, rarity: 3, unique: true },
        { id: "EB6", name: {en: "Pad", cn: "铺底音色"}, desc: {en: "Gain 30 Groove on trigger.<br>During Duration: For every 1 [Empty Slot] currently on the field, gain +5% Groove.", cn: "触发时获得 30 Groove。<br>持续期间全场每存在 1个[空拍]，自身 Groove +5%。"}, len: 8, cpu: 2, base: 30, type: "score", color: "#ffca28", price: 100, rarity: 2 },
        { id: "NG1", name: {en: "Viral Hit", cn: "网红单曲"}, desc: {en: "Gain 30 Groove on trigger.<br>On Sold: Based on cumulative times played (Current: X), immediately apply a discount to the entire Shop.", cn: "触发时获得 30 Groove。<br>离场：卖出此道具时，基于累计上场次数（当前：X次），立即使商店全场打折。"}, len: 8, cpu: 1, base: 30, type: "score", color: "#cfd8dc", price: 75, rarity: 1 },
        { id: "NG2", name: {en: "Layering", cn: "叠层"}, desc: {en: "Gain 20 Groove on trigger.<br>If other items trigger in [Sync], gain an additional 10 Groove.", cn: "触发时获得 20 Groove。<br>若有其他道具[同步]触发，额外获得 10 Groove。"}, len: 4, cpu: 1, base: 20, type: "score", color: "#b0bec5", price: 75, rarity: 1 },
        { id: "NG3", name: {en: "Solo Fader", cn: "独奏推子"}, desc: {en: "Increase Groove of Previous and Next items on [Same Track] by +35%.<br>If no other items trigger in [Sync], increase this effect by an additional +35%.", cn: "[同轨]使前后道具 Groove +35%。<br>若触发时没有其他道具[同步]触发，该增幅额外 +35%。"}, len: 2, cpu: 1, base: 0, type: "support", color: "#90a4ae", price: 100, rarity: 2 },
        { id: "NG4", name: {en: "Noise Gate", cn: "降噪门"}, desc: {en: "Unique (Only one copy allowed).<br>[Consume]: Reduce Groove of all [Sync] triggering items by 50%.<br>Self gains Groove = (40 + [Consumed] amount) x 1.5.", cn: "唯一，只能同时存在一个同名道具。<br>[吞噬]：使所有[同步]触发的道具 Groove 减半。<br>自身获得 Groove = (40 + [吞噬]数值) x 1.5。"}, len: 4, cpu: 2, base: 40, type: "score", color: "#78909c", price: 150, rarity: 3, unique: true },
        { id: "TUT1", name: {en: "Sampler A", cn: "采样器 A"}, desc: {en: "Gain 20 Groove.", cn: "获得 20 Groove。"}, len: 4, cpu: 1, base: 20, type: "score", color: "#ddd", price: 0, rarity: 1 },
        { id: "TUT2", name: {en: "Sampler B", cn: "采样器 B"}, desc: {en: "Gain 30 Groove.", cn: "获得 30 Groove。"}, len: 8, cpu: 1, base: 30, type: "score", color: "#bbb", price: 0, rarity: 1 }
    ];
    
    const LEVEL_CONFIG = [
        { tracks: 2, target: 324,  reward: 200, poolAdds: ["NG1", "EB2", "EB3", "SB2", "NG3"] },
        { tracks: 2, target: 420,  reward: 250, poolAdds: ["SB3", "EB6"] },
        { tracks: 3, target: 576,  reward: 350, poolAdds: ["SB4", "NG4", "EB4"] },
        { tracks: 3, target: 735,  reward: 450, poolAdds: ["SB5", "EB5"] },
        { tracks: 3, target: 925,  reward: 600, poolAdds: [] },
        { tracks: 3, target: 1200, reward: 0,   poolAdds: [] }
    ];

    const TUTORIAL_CONFIG = [
        { tracks: 1, target: 130, reward: 100, startCpu: 5, initialItems: ["TUT1", "TUT2"], poolAdds: [] },
        { tracks: 1, target: 150, reward: 130, poolAdds: ["EB1"] },
        { tracks: 1, target: 185, reward: 220, poolAdds: ["SB1"], oneTimeCpu: true },
        { tracks: 2, target: 270, reward: 0, poolAdds: ["EB2"], repeatableCpu: true, failReward: 110 }
    ];

    // Rare item pool for milestone rewards (3 engines + Noise Gate)
    const RARE_ITEM_POOL = ['SB4', 'SB5', 'EB5', 'NG4']; // Master Clock, Quantizer, Time Stretch, Noise Gate

    let config = { maxCpu: 12, target: 324, activeTracks: 2 };
    let state = {
        inventory: [], placedItems: [], poolIds: [], poolEntryTimes: {}, 
        levelIndex: 0, selectedInvItem: null, shopLocked: false, isPlaying: false,
        gold: 150, cpuPurchasedRound: 0, roundBase: 10, currentShopItems: [],
        ng1PermanentStacks: 0, lastRoundReward: 0,
        milestoneProgress: 0, // Tier 3 milestone progress (0, 1, or 2)
        lang: 'en', isTutorial: false, tutorialCpuBought: false,
        lastResultData: null, lastTotalScore: 0, isSimulation: false, unlockedTracks: 1,
        discordShown: false
    };

    let dragManager = { active: false, itemData: null, sourceType: null, sourceRecord: null, sourceInvItem: null, ghostEl: null, previewEl: null, sellTooltip: null, currentHover: null, startX: 0, startY: 0 };
    let tutorialState = { 
        l1: { aClicked: false, bClicked: false, aPlaced: false, bPlaced: false }, 
        l2: { bought: false, clicked: false, effectActive: false }, 
        l3: { kickBought: false, cpuBought: false, kickClicked: false, kickEffect: false }, 
        l4: { cpuCount: 0, trackUnlocked: false, resultGuideShown: false, padGiven: false, simScore: null } 
    };
    
    // === STRONG GUIDE SYSTEM ===
    let guideState = {
        active: false,
        currentStep: 0,
        waitingFor: null, // 'click', 'place', 'buy', 'sell', 'sellBoth', 'shopItemClick', 'cpuBuy', 'cpuBuy3'
        highlightedElement: null,
        completedLevels: {}, // Track which levels have shown guides
        l4SoldCount: 0, // Track sold items in level 4
        l4CpuBuyCount: 0, // Track CPU purchases in level 4
        levelGuides: {
            // Level 1 guides - pos: where to place message to not block target
            0: [
                { target: 'targetContainer', pos: 'left', msg: { en: 'This is your TARGET GROOVE. You must reach this score to pass the level!', cn: '这是你的目标分数。你必须达到这个分数才能通关！' }, wait: 'click' },
                { target: ['invPanel', 'trackArea'], pos: 'bottom', msg: { en: 'Drag items from INVENTORY to the DAW tracks to place them. Items will generate Groove when triggered!', cn: '从库存中拖拽道具到DAW音轨上放置。道具被触发时会产生分数！' }, wait: 'place' },
                { target: 'detailPanel', pos: 'above', msg: { en: 'Check the DESCRIPTION panel to see how much Groove each item provides. Plan your placement wisely!', cn: '查看描述面板了解每个道具能提供多少分数。合理规划放置位置！' }, wait: 'click' },
                { target: ['cpuContainer', 'trackArea'], pos: 'center-down', msg: { en: 'Items cost CPU and SPACE. When you run out of either, you cannot place more items. Manage your resources!', cn: '道具需要消耗CPU和空间。当任一资源耗尽时，就无法放置更多道具了。合理管理资源！' }, wait: 'click' }
            ],
            // Level 2 guides
            1: [
                { target: 'shopList', pos: 'left-of-shop', msg: { en: 'Click on shop items to view their description before buying. Some items have special effects!', cn: '购买前先点击商店道具查看描述。有些道具有特殊效果！' }, wait: 'shopItemClick' }
            ],
            // Level 3 guides - CPU upgrade near the button
            2: [
                { target: 'btnBuyCpu', pos: 'near-cpu-btn', msg: { en: 'Buy CPU to permanently increase your CPU limit. More CPU = more items you can place!', cn: '购买CPU可以永久提升CPU上限。更多CPU = 可放置更多道具！' }, wait: 'cpuBuy' }
            ],
            // Level 4 guides - sell samplers, buy CPU, learn tiers and preview
            3: [
                { target: 'shopList', pos: 'center-down', highlightSamplers: true, msg: { en: 'Drag Sampler A and B to the SHOP to sell them. These tutorial items are no longer needed!', cn: '将采样器A和B拖拽到商店出售。这两个教学道具已经不再需要了！' }, wait: 'sellBoth' },
                { target: 'btnBuyCpu', pos: 'near-cpu-btn', msg: { en: 'You can buy CPU multiple times per level! The price increases slightly each time. Buy CPU 3 times to continue.', cn: '每关可以多次购买CPU！每次价格会略微递增。购买3次CPU后继续。' }, wait: 'cpuBuy3' },
                { target: 'tierContainer', pos: 'above-tier', msg: { en: 'In standard mode, there are THREE tiers of success! Higher scores give better rewards. Aim for ★★★ to earn bonus CPU and rare items! In this tutorial level, achieving ★★★ will grant you a powerful item that carries over to standard mode!', cn: '在正式关卡中，有三个通关等级！分数越高奖励越好。追求★★★可以获得额外CPU和稀有道具奖励！在这一关达成★★★，你可以在接下来的正式关卡中获得一个额外的强力道具！' }, wait: 'click' },
                { target: 'simBtn', pos: 'center', msg: { en: 'TIP: Before submitting, use SIMULATE to check your current score without risk!', cn: '提示：正式提交前，可以使用试听功能无风险查看当前分数！' }, wait: 'click' }
            ]
        }
    };
    
    function startLevelGuide(levelIdx) {
        if (!state.isTutorial) return;
        // Only show guide once per level (not on retry)
        if (guideState.completedLevels[levelIdx]) return;
        
        const guides = guideState.levelGuides[levelIdx];
        if (!guides || guides.length === 0) return;
        
        // Reset level 4 specific counters
        if (levelIdx === 3) {
            guideState.l4SoldCount = 0;
            guideState.l4CpuBuyCount = 0;
        }
        
        guideState.active = true;
        guideState.currentStep = 0;
        showGuideStep(levelIdx, 0);
    }
    
    function showGuideStep(levelIdx, stepIdx) {
        const guides = guideState.levelGuides[levelIdx];
        if (!guides || stepIdx >= guides.length) {
            hideGuide();
            guideState.completedLevels[levelIdx] = true; // Mark level guide as completed
            return;
        }
        
        const step = guides[stepIdx];
        guideState.waitingFor = step.wait;
        
        // Show overlay
        document.getElementById('guideOverlay').style.display = 'block';
        
        // Highlight target element(s)
        clearGuideHighlight();
        const targets = Array.isArray(step.target) ? step.target : [step.target];
        
        // Special: highlight only Sampler A/B for sell tutorial (not all inv items)
        if (step.highlightSamplers) {
            highlightSamplerItems();
        } else {
            targets.forEach(t => {
                const el = document.getElementById(t);
                if (el) {
                    el.classList.add('guide-highlight');
                    guideState.highlightedElement = el;
                }
            });
        }
        
        // Position and show message
        const msgBox = document.getElementById('guideMessage');
        const title = state.lang === 'cn' ? '教程提示' : 'Tutorial';
        let text = step.msg[state.lang];
        
        // Show progress for sellBoth
        if (step.wait === 'sellBoth') {
            text += ` (${guideState.l4SoldCount}/2)`;
        }
        // Show progress for cpuBuy3
        if (step.wait === 'cpuBuy3') {
            text += ` (${guideState.l4CpuBuyCount}/3)`;
        }
        
        const btnText = step.wait === 'click' ? (state.lang === 'cn' ? '知道了' : 'Got it!') : (state.lang === 'cn' ? '请操作...' : 'Try it...');
        
        document.getElementById('guideTitle').innerText = title;
        document.getElementById('guideText').innerText = text;
        document.getElementById('guideBtn').innerText = btnText;
        document.getElementById('guideBtn').disabled = (step.wait !== 'click');
        
        // Position message strategically to NOT block target
        // Reset all position styles first to avoid conflicts
        msgBox.style.top = '';
        msgBox.style.bottom = '';
        msgBox.style.left = '';
        msgBox.style.right = '';
        msgBox.style.transform = '';
        
        const pos = step.pos || 'bottom';
        
        switch(pos) {
            case 'left': {
                // Place to the left of the target (good for targetContainer on right side)
                const targetEl = document.getElementById(targets[0]);
                if (targetEl) {
                    const rect = targetEl.getBoundingClientRect();
                    msgBox.style.top = Math.max(10, rect.top) + 'px';
                    msgBox.style.left = Math.max(20, rect.left - 450 - 30) + 'px';
                } else {
                    msgBox.style.top = '100px';
                    msgBox.style.left = '20px';
                }
                break;
            }
            case 'above': {
                // Place above the target (good for description panel at bottom)
                const targetEl = document.getElementById(targets[0]);
                if (targetEl) {
                    const rect = targetEl.getBoundingClientRect();
                    msgBox.style.top = Math.max(10, rect.top - 180 - 20) + 'px';
                    msgBox.style.left = Math.max(20, rect.left) + 'px';
                } else {
                    msgBox.style.top = '50%';
                    msgBox.style.left = '20px';
                }
                break;
            }
            case 'center-down': {
                // Center of screen, slightly below middle - good for general info
                msgBox.style.top = '55%';
                msgBox.style.left = '50%';
                msgBox.style.transform = 'translate(-50%, -50%)';
                break;
            }
            case 'center': {
                // True center of screen
                msgBox.style.top = '50%';
                msgBox.style.left = '50%';
                msgBox.style.transform = 'translate(-50%, -50%)';
                break;
            }
            case 'above-tier': {
                // Above the tier display area (bottom right info panel)
                const tierEl = document.getElementById('tierContainer');
                if (tierEl) {
                    const rect = tierEl.getBoundingClientRect();
                    msgBox.style.top = Math.max(60, rect.top - 200) + 'px';
                    msgBox.style.left = Math.max(20, rect.left - 400) + 'px';
                } else {
                    msgBox.style.top = '40%';
                    msgBox.style.left = '50%';
                    msgBox.style.transform = 'translate(-50%, -50%)';
                }
                break;
            }
            case 'near-cpu-btn': {
                // Right side, near the CPU upgrade button
                const cpuBtn = document.getElementById('btnBuyCpu');
                const shopPanel = document.getElementById('shopPanel');
                if (cpuBtn && shopPanel) {
                    const btnRect = cpuBtn.getBoundingClientRect();
                    const shopRect = shopPanel.getBoundingClientRect();
                    msgBox.style.top = Math.max(80, btnRect.top - 20) + 'px';
                    msgBox.style.right = (window.innerWidth - shopRect.left + 10) + 'px';
                } else {
                    msgBox.style.top = '200px';
                    msgBox.style.right = '280px';
                }
                break;
            }
            case 'left-of-shop': {
                // Place to the left of shop panel (right side of screen)
                const shopPanel = document.getElementById('shopPanel');
                if (shopPanel) {
                    const rect = shopPanel.getBoundingClientRect();
                    msgBox.style.top = Math.max(80, rect.top + 50) + 'px';
                    msgBox.style.left = Math.max(20, rect.left - 450 - 30) + 'px';
                } else {
                    msgBox.style.top = '50%';
                    msgBox.style.left = '20px';
                }
                break;
            }
            case 'bottom': 
            default: {
                // Place at bottom of screen (good for inventory/DAW tutorials)
                msgBox.style.bottom = '20px';
                msgBox.style.left = '50%';
                msgBox.style.transform = 'translateX(-50%)';
                break;
            }
        }
        
        msgBox.style.display = 'block';
    }
    
    function highlightSamplerItems() {
        // Find and highlight only Sampler A and B in inventory
        document.querySelectorAll('.inv-item').forEach(el => {
            const itemId = el.getAttribute('data-id');
            if (itemId === 'TUT1' || itemId === 'TUT2') { // Sampler A and B
                el.classList.add('guide-highlight');
            }
        });
        // Also highlight shop list as the drop target (NOT the whole shopPanel with CPU button)
        const shopList = document.getElementById('shopList');
        if (shopList) shopList.classList.add('guide-highlight');
    }
    
    function advanceGuide() {
        if (!guideState.active) return;
        
        guideState.currentStep++;
        const guides = guideState.levelGuides[state.levelIndex];
        
        if (guideState.currentStep >= guides.length) {
            hideGuide();
        } else {
            showGuideStep(state.levelIndex, guideState.currentStep);
        }
    }
    
    function hideGuide() {
        guideState.active = false;
        guideState.waitingFor = null;
        document.getElementById('guideOverlay').style.display = 'none';
        document.getElementById('guideMessage').style.display = 'none';
        clearGuideHighlight();
    }
    
    function clearGuideHighlight() {
        document.querySelectorAll('.guide-highlight').forEach(el => el.classList.remove('guide-highlight'));
    }
    
    function checkGuideAction(action, extraData) {
        if (!guideState.active || !guideState.waitingFor) return;
        
        // Handle sellBoth - need to sell 2 items
        if (guideState.waitingFor === 'sellBoth' && action === 'sell') {
            guideState.l4SoldCount++;
            // Update message to show progress
            const step = guideState.levelGuides[state.levelIndex][guideState.currentStep];
            let text = step.msg[state.lang] + ` (${guideState.l4SoldCount}/2)`;
            document.getElementById('guideText').innerText = text;
            
            // Re-highlight remaining samplers
            clearGuideHighlight();
            highlightSamplerItems();
            
            if (guideState.l4SoldCount >= 2) {
                document.getElementById('guideBtn').disabled = false;
                document.getElementById('guideBtn').innerText = state.lang === 'cn' ? '继续' : 'Continue';
                setTimeout(advanceGuide, 500);
            }
            return;
        }
        
        // Handle cpuBuy3 - need to buy CPU 3 times
        if (guideState.waitingFor === 'cpuBuy3' && action === 'cpuBuy') {
            guideState.l4CpuBuyCount++;
            // Update message to show progress
            const step = guideState.levelGuides[state.levelIndex][guideState.currentStep];
            let text = step.msg[state.lang] + ` (${guideState.l4CpuBuyCount}/3)`;
            document.getElementById('guideText').innerText = text;
            
            if (guideState.l4CpuBuyCount >= 3) {
                document.getElementById('guideBtn').disabled = false;
                document.getElementById('guideBtn').innerText = state.lang === 'cn' ? '继续' : 'Continue';
                setTimeout(advanceGuide, 500);
            }
            return;
        }
        
        if (guideState.waitingFor === action) {
            document.getElementById('guideBtn').disabled = false;
            document.getElementById('guideBtn').innerText = state.lang === 'cn' ? '继续' : 'Continue';
            // Auto advance for some actions
            if (action === 'place' || action === 'cpuBuy' || action === 'sell') {
                setTimeout(advanceGuide, 500);
            }
        }
    }
    
    function resetTutorialStateForLevel(idx) { if (idx === 0) tutorialState.l1 = { aClicked: false, bClicked: false, aPlaced: false, bPlaced: false }; if (idx === 1) { tutorialState.l2.clicked = false; tutorialState.l2.effectActive = false; } if (idx === 2) { tutorialState.l3.kickClicked = false; tutorialState.l3.kickEffect = false; } if (idx === 3) { tutorialState.l4.cpuCount = 0; tutorialState.l4.simScore = null; /* Keep trackUnlocked and resultGuideShown */ } }

    // --- Init ---
    window.addEventListener('DOMContentLoaded', () => { 
        window.debugSetGold = () => { const val = parseInt(document.getElementById('dbgGold').value); if(!isNaN(val)) { state.gold = val; updateUI(); } };
        window.debugSetTarget = () => { const val = parseInt(document.getElementById('dbgTarget').value); if(!isNaN(val)) { config.target = val; updateUI(); } };
        initGrid(); updateAllText(); 
        window.addEventListener('mousemove', onGlobalDragMove);
        window.addEventListener('mouseup', onGlobalDragEnd);
        setInterval(updateTutorialVisuals, 200);
    });

    // --- Logic ---
    function getSourceName(id) {
        if(id === 'Self' || id === 'Self Condition') return UI_TEXT[state.lang].self;
        if(id === 'Global') return UI_TEXT[state.lang].global;
        const item = DB.find(i => i.id === id || i.name.en === id || i.name.cn === id);
        return item ? item.name[state.lang] : id;
    }

    function calculateLogic() { 
        const items = state.placedItems; 
        const sorted = [...items].sort((a,b) => a.start - b.start); 
        let output = sorted.map(p => ({ 
            record: p, base: p.data.base, bonus: 0, mult: 1.0, finalMultiplier: 1.0, 
            triggered: false, buffsReceived: [], buffsGiven: [], logs: [], forceStrong: false 
        })); 
        
        let globalWeakIsStrong = false; let globalGapMult = 1;          
        output.forEach(entry => { 
            const d = entry.record.data; const s = entry.record.start; 
            if (d.id === "SB5" && (s % 8 === 0)) { globalWeakIsStrong = true; entry.triggered = true; entry.logs.push({srcId:'Global', type:'rule', val:'Quantizer Active', order: 5}); } 
            if (d.id === "EB5") { globalGapMult = 2; entry.triggered = true; entry.logs.push({srcId:'Global', type:'rule', val:'Time Stretch Active', order: 5}); } 
        }); 

        let strongBeatCount = 0; let sb4Triggered = false; 
        output.forEach((entry, idx) => { 
            const p = entry.record; const d = p.data; const s = p.start; const e = s + d.len; 
            const beatIdx = Math.floor(s / 4); let isNaturalStrong = (beatIdx % 2 === 0); let isStrong = isNaturalStrong || globalWeakIsStrong || entry.forceStrong; 
            if (isStrong && (d.id.startsWith("SB") || d.id.startsWith("NG"))) strongBeatCount++; 
            if (isStrong) entry.logs.push({srcId:'System', type:'cond', val:'Strong Beat', order: 5});

            const trackItems = output.filter(x => x.record.track === p.track); const tIdx = trackItems.indexOf(entry); const prev = tIdx > 0 ? trackItems[tIdx-1] : null; const next = tIdx < trackItems.length-1 ? trackItems[tIdx+1] : null; const concurrent = output.filter(x => x !== entry && x.record.start === s); 
            const calcGap = (t1, t2) => Math.max(0, t2 - t1) * globalGapMult; 

            if (d.id === "SB1") { if (isStrong) { entry.bonus += 10; entry.triggered = true; entry.logs.push({srcId:'Self', type:'cond', val:'+10 (Strong)', order: 2}); } } 
            else if (d.id === "SB2") { 
                if (concurrent.length > 0) concurrent.forEach(t => { t.mult += 0.5; t.buffsReceived.push({text:`[${d.name[state.lang]}] +50%`, type:d.type}); t.logs.push({srcId:d.id, srcIdx:idx, type:'buff', val:'+50% (Sync)', order: 5}); entry.buffsGiven.push({targetIdx: output.indexOf(t)}); }); 
                if (isStrong && concurrent.length > 0) { concurrent.forEach(t => { t.mult += 0.25; t.buffsReceived.push({text:`[${d.name[state.lang]}] +25%`, type:d.type}); t.logs.push({srcId:d.id, srcIdx:idx, type:'buff', val:'+25% (Strong Sync)', order: 5}); }); entry.triggered = true; } 
            } 
            else if (d.id === "SB3") { 
                if (next) { next.mult += 1.0; next.buffsReceived.push({text:`[${d.name[state.lang]}] +100%`, type:d.type}); next.logs.push({srcId:d.id, srcIdx:idx, type:'buff', val:'+100% (Next)', order: 5}); entry.buffsGiven.push({targetIdx: output.indexOf(next)}); } 
                if (isStrong && next) { next.forceStrong = true; entry.triggered = true; next.logs.push({srcId:d.id, srcIdx:idx, type:'rule', val:'Force Strong', order: 5}); entry.buffsGiven.push({targetIdx: output.indexOf(next), type:'engine'}); } 
            } 
            else if (d.id === "SB4") { 
                if (isStrong && strongBeatCount > 5 && !sb4Triggered) { 
                    sb4Triggered = true; entry.triggered = true; 
                    for (let i = idx + 1; i < output.length; i++) { 
                        const target = output[i]; const tS = target.record.start; const tBeat = Math.floor(tS/4); const tNatStrong = (tBeat%2===0); const tIsStrong = tNatStrong || globalWeakIsStrong || target.forceStrong; 
                        if (tIsStrong && target.record.data.type === "score") { target.finalMultiplier *= 1.5; target.buffsReceived.push({text:`[${d.name[state.lang]}] x1.5`, type:d.type}); target.logs.push({srcId:d.id, srcIdx:idx, type:'buff', val:'x1.5 (Master)', order: 6}); entry.buffsGiven.push({targetIdx: i, type:'engine'}); } 
                    } 
                } 
            } 
            else if (d.id === "EB1") { if (prev) { const gap = calcGap(prev.record.start + prev.record.data.len, s); if (gap >= 4) { entry.bonus += 20; entry.triggered = true; entry.logs.push({srcId:'Self', type:'cond', val:'+20 (Gap>=4)', order: 2}); } } } 
            else if (d.id === "EB2") { 
                if (next) { 
                    next.mult += 0.35; next.buffsReceived.push({text:`[${d.name[state.lang]}] +35%`, type:d.type}); next.logs.push({srcId:d.id, srcIdx:idx, type:'buff', val:'+35% (Pre)', order: 5}); entry.buffsGiven.push({targetIdx: output.indexOf(next)});
                    const gap = calcGap(e, next.record.start); 
                    if (gap > 0) { let extra = Math.min(1.25, gap * 0.125); next.mult += extra; next.buffsReceived.push({text:`[${d.name[state.lang]}] +${(extra*100).toFixed(0)}%`, type:d.type}); next.logs.push({srcId:d.id, srcIdx:idx, type:'buff', val:`+${(extra*100).toFixed(0)}% (Gap)`, order: 5}); entry.triggered = true; } 
                } 
            } 
            else if (d.id === "EB3") { 
                if (concurrent.length > 0) concurrent.forEach(t => { if(t.record.data.type==="score") { t.bonus += 10; t.logs.push({srcId:d.id, srcIdx:idx, type:'buff', val:'+10 (Iso)', order: 3}); } }); 
                let gapTotal = 0; if(prev) gapTotal += calcGap(prev.record.start+prev.record.data.len, s); if(next) { gapTotal += calcGap(e, next.record.start); } else { gapTotal += calcGap(e, TICKS); } 
                if (gapTotal > 0) { let extraMult = Math.min(2.4, gapTotal * 0.075); concurrent.forEach(t => { if(t.record.data.type === "score") { t.mult += extraMult; t.buffsReceived.push({text:`[${d.name[state.lang]}] +${(extraMult*100).toFixed(1)}%`, type:d.type}); t.logs.push({srcId:d.id, srcIdx:idx, type:'buff', val:`+${(extraMult*100).toFixed(0)}% (Iso Gap)`, order: 5}); entry.buffsGiven.push({targetIdx: output.indexOf(t)}); } }); entry.triggered = true; } 
            } 
            else if (d.id === "EB4") { let totalSpace = s * 3; let occupied = 0; items.forEach(it => { let iS = it.start; let iE = it.start + it.data.len; if (iE <= s) occupied += it.data.len; else if (iS < s) occupied += (s - iS); }); let empty = Math.max(0, totalSpace - occupied) * globalGapMult; if (empty > 0) { let boost = empty * 0.05; entry.mult += boost; entry.buffsReceived.push({text:`[空拍] +${(boost*100).toFixed(0)}%`, type:d.type}); entry.triggered = true; entry.logs.push({srcId:'Self', type:'cond', val:`+${(boost*100).toFixed(0)}% (Atmo)`, order: 4});} } 
            else if (d.id === "EB6") { let dur = e - s; let totalSpace = dur * 3; let occupied = 0; items.forEach(it => { if (it === p) return; let iS = it.start; let iE = it.start + it.data.len; let overlap = Math.max(0, Math.min(e, iE) - Math.max(s, iS)); occupied += overlap; }); occupied += dur; let empty = Math.max(0, totalSpace - occupied) * globalGapMult; if (empty > 0) { let boost = empty * 0.05; entry.mult += boost; entry.buffsReceived.push({text:`[${d.name[state.lang]}] +${(boost*100).toFixed(0)}%`, type:d.type}); entry.triggered = true; entry.logs.push({srcId:'Self', type:'cond', val:`+${(boost*100).toFixed(0)}% (Pad)`, order: 4});} } 
            else if (d.id === "NG2") { if (concurrent.length > 0) { entry.bonus += 10; entry.triggered = true; entry.logs.push({srcId:'Self', type:'cond', val:'+10 (Sync)', order: 2}); } } 
            else if (d.id === "NG3") { 
                if (prev) { prev.mult += 0.35; prev.buffsReceived.push({text:`[${d.name[state.lang]}] +35%`, type:d.type}); prev.logs.push({srcId:d.id, srcIdx:idx, type:'buff', val:'+35%', order: 5}); entry.buffsGiven.push({targetIdx: output.indexOf(prev)}); } 
                if (next) { next.mult += 0.35; next.buffsReceived.push({text:`[${d.name[state.lang]}] +35%`, type:d.type}); next.logs.push({srcId:d.id, srcIdx:idx, type:'buff', val:'+35%', order: 5}); entry.buffsGiven.push({targetIdx: output.indexOf(next)}); } 
                if (concurrent.length === 0) { if (prev) { prev.mult += 0.35; prev.buffsReceived.push({text:`[${d.name[state.lang]}] +35%`, type:d.type}); prev.logs.push({srcId:d.id, srcIdx:idx, type:'buff', val:'+35% (Solo)', order: 5}); } if (next) { next.mult += 0.35; next.buffsReceived.push({text:`[${d.name[state.lang]}] +35%`, type:d.type}); next.logs.push({srcId:d.id, srcIdx:idx, type:'buff', val:'+35% (Solo)', order: 5}); } entry.triggered = true; } 
            } 
        }); 
        output.forEach(entry => { 
            const d = entry.record.data; 
            if (d.id === "NG4") { 
                const s = entry.record.start; const concurrent = output.filter(x => x !== entry && x.record.start === s); let suckedScore = 0; 
                concurrent.forEach(t => { if (t.record.data.type === "score") { let current = (t.base + t.bonus) * t.mult * t.finalMultiplier; t.finalMultiplier *= 0.5; t.buffsReceived.push({text:`[${d.name[state.lang]}] -50%`, type:d.type}); t.logs.push({srcId:d.id, srcIdx: output.indexOf(entry), type:'nerf', val:'-50% (Consumed)', order: 6}); let now = (t.base + t.bonus) * t.mult * t.finalMultiplier; suckedScore += (current - now); entry.buffsGiven.push({targetIdx: output.indexOf(t), type:'consume'}); } }); 
                if (suckedScore > 0) { 
                    const consumeBonus = Math.floor(suckedScore * 1.5);
                    entry.bonus += 20 + consumeBonus; 
                    entry.buffsReceived.push({text:`+${consumeBonus}`, type:d.type}); 
                    entry.triggered = true;
                    // Add log for consume bonus display in result
                    entry.logs.push({srcId:'Self', type:'cond', val:`+${consumeBonus} (Consume)`, order: 3});
                } 
            } 
        }); 
        return output; 
    }

    // --- Audio & Visual ---
    let visualInterval = null; let playbackStartTime = 0; let playbackTimer = null; let audioInitialized = false; let isSkipping = false;
    let bgPlayers = {}; // V26.0: tutorial and standard BGM players
    let samplePlayers = null; // Item sound players
    let effects = {}; // Audio effects chain
    let activeBeams = [];
    let currentTier = 0; // Current audio tier (-4 to +4)
    let playbackSpeed = 1; // Speed multiplier (1 = normal, 4 = fast forward)
    let speedChangeTime = 0; // When speed changed
    let positionAtSpeedChange = 0; // Position (0-1) when speed changed

    // === 9-TIER AUDIO QUALITY SYSTEM ===
    // Maps score ratio to audio quality tier
    // Tier -4: 60% of target (sounds bad), Tier 0: 100% (normal), Tier +4: 140% (sounds great)
    // MORE DRAMATIC differences for clearer feedback
    const TIER_CONFIG = {
        // Tier: filter (Hz), bits, reverb wet, volume offset (dB)
        '-4': { ratio: [0.00, 0.65], filter: 1200,  bits: 5,  reverb: 0,    volume: -6 },  // Very muffled, harsh digital
        '-3': { ratio: [0.65, 0.75], filter: 2000,  bits: 7,  reverb: 0,    volume: -4 },  // Muffled, noticeable artifacts
        '-2': { ratio: [0.75, 0.85], filter: 4000,  bits: 10, reverb: 0,    volume: -2 },  // Dull, some artifacts
        '-1': { ratio: [0.85, 0.95], filter: 8000,  bits: 13, reverb: 0,    volume: -1 },  // Slightly muffled
        '0':  { ratio: [0.95, 1.05], filter: 20000, bits: 16, reverb: 0,    volume: 0  },  // Clean, normal
        '+1': { ratio: [1.05, 1.15], filter: 20000, bits: 16, reverb: 0.12, volume: 1  },  // Slight sparkle
        '+2': { ratio: [1.15, 1.25], filter: 20000, bits: 16, reverb: 0.20, volume: 2  },  // Nice ambience
        '+3': { ratio: [1.25, 1.35], filter: 20000, bits: 16, reverb: 0.30, volume: 3  },  // Rich, spacious
        '+4': { ratio: [1.35, 9.99], filter: 20000, bits: 16, reverb: 0.40, volume: 4  }   // Amazing, full
    };

    function calculateTier(score, target) {
        const ratio = score / target;
        for (const [tier, cfg] of Object.entries(TIER_CONFIG)) {
            if (ratio >= cfg.ratio[0] && ratio < cfg.ratio[1]) {
                return parseInt(tier);
            }
        }
        return ratio >= 1.35 ? 4 : -4; // Fallback
    }

    function getTierLabel(tier) {
        const labels = {
            '-4': { en: '😫 Dissonant', cn: '😫 刺耳' },
            '-3': { en: '😕 Off-key', cn: '😕 走调' },
            '-2': { en: '😐 Rough', cn: '😐 粗糙' },
            '-1': { en: '🙂 Almost', cn: '🙂 差一点' },
            '0':  { en: '✓ Complete', cn: '✓ 完整' },
            '+1': { en: '🎵 Good', cn: '🎵 好听' },
            '+2': { en: '🎶 Great', cn: '🎶 很棒' },
            '+3': { en: '✨ Excellent', cn: '✨ 出色' },
            '+4': { en: '🔥 Perfect!', cn: '🔥 完美！' }
        };
        return labels[tier.toString()] || labels['0'];
    }

    async function initAudio() {
        if(audioInitialized) return;
        const btn = document.getElementById('mainSubmitBtn'); if(btn) btn.innerText = "Loading...";
        await Tone.start();
        
        // === V26.0 SIMPLIFIED EFFECTS CHAIN ===
        // BGM chain (quiet background)
        effects.bgmGain = new Tone.Gain(0.3); // BGM is quiet background
        effects.bgmFilter = new Tone.Filter(20000, "lowpass");
        
        // Item effects chain (louder, main content)
        effects.itemGain = new Tone.Gain(1); // Items are the main audio
        effects.itemFilter = new Tone.Filter(20000, "lowpass");
        effects.itemReverb = new Tone.Reverb({ decay: 2.0, wet: 0 });
        
        // Master output
        effects.masterGain = new Tone.Gain(1);
        
        // === SIMPLIFIED BGM: One track per mode ===
        bgPlayers.tutorial = new Tone.Player({ url: AUDIO_SOURCES.bgm_tutorial, loop: true, fadeOut: 0.1, fadeIn: 0.1, volume: -6 });
        bgPlayers.standard = new Tone.Player({ url: AUDIO_SOURCES.bgm_standard, loop: true, fadeOut: 0.1, fadeIn: 0.1, volume: -6 });
        
        // Connect BGM chain
        bgPlayers.tutorial.disconnect(); bgPlayers.tutorial.connect(effects.bgmFilter);
        bgPlayers.standard.disconnect(); bgPlayers.standard.connect(effects.bgmFilter);
        effects.bgmFilter.connect(effects.bgmGain);
        effects.bgmGain.connect(effects.masterGain);
        
        // Item sounds - these are the MAIN audio content
        const itemUrls = {}; 
        for (const [key, url] of Object.entries(AUDIO_SOURCES)) { 
            if (!key.startsWith('bgm')) itemUrls[key] = url; 
        }
        samplePlayers = new Tone.Players({ urls: itemUrls, fadeOut: 0.05, volume: 0 });
        
        // Connect item chain (separate from BGM for independent tier control)
        samplePlayers.disconnect();
        samplePlayers.connect(effects.itemFilter);
        effects.itemFilter.connect(effects.itemReverb);
        effects.itemReverb.connect(effects.itemGain);
        effects.itemGain.connect(effects.masterGain);
        
        // Master to destination
        effects.masterGain.toDestination();
        
        try {
            await Tone.loaded();
            console.log('✅ V26.0 Audio system loaded');
        } catch(e) {
            console.warn('⚠️ Some audio files failed to load:', e);
        }
        
        // Get duration from tutorial BGM
        if (bgPlayers.tutorial.buffer && bgPlayers.tutorial.buffer.duration > 0) { 
            TOTAL_DURATION = bgPlayers.tutorial.buffer.duration; 
            TICK_DURATION = TOTAL_DURATION / TICKS; 
        }
        if(btn) btn.innerText = UI_TEXT[state.lang].submit;
        audioInitialized = true;
    }
    
    // === V26.0 TIER-BASED ITEM AUDIO EFFECTS ===
    // Apply audio effects to items based on score vs target ratio
    // Only affects playback, not DAW editing
    function applyItemTierEffects(scoreRatio) {
        if (!audioInitialized) return;
        
        // 9 tiers from -20% to +20% of target, each 5%
        // Tier affects: filter cutoff, reverb, volume
        let filterFreq = 20000;
        let reverbWet = 0;
        let volumeDb = 0;
        
        if (scoreRatio < 0.80) {
            // Very bad: muffled, no reverb
            filterFreq = 2000;
            reverbWet = 0;
            volumeDb = -4;
        } else if (scoreRatio < 0.85) {
            filterFreq = 4000;
            reverbWet = 0;
            volumeDb = -3;
        } else if (scoreRatio < 0.90) {
            filterFreq = 6000;
            reverbWet = 0;
            volumeDb = -2;
        } else if (scoreRatio < 0.95) {
            filterFreq = 10000;
            reverbWet = 0.05;
            volumeDb = -1;
        } else if (scoreRatio < 1.00) {
            // Near target: clean
            filterFreq = 15000;
            reverbWet = 0.1;
            volumeDb = 0;
        } else if (scoreRatio < 1.05) {
            // At target: good
            filterFreq = 20000;
            reverbWet = 0.15;
            volumeDb = 1;
        } else if (scoreRatio < 1.10) {
            filterFreq = 20000;
            reverbWet = 0.2;
            volumeDb = 2;
        } else if (scoreRatio < 1.15) {
            filterFreq = 20000;
            reverbWet = 0.25;
            volumeDb = 3;
        } else {
            // Excellent: full, spacious
            filterFreq = 20000;
            reverbWet = 0.35;
            volumeDb = 4;
        }
        
        // Apply to item effects chain
        if (effects.itemFilter) effects.itemFilter.frequency.value = filterFreq;
        if (effects.itemReverb) effects.itemReverb.wet.value = reverbWet;
        if (effects.itemGain) effects.itemGain.gain.value = Math.pow(10, volumeDb / 20);
        
        console.log(`🎵 Item tier effects: ratio=${scoreRatio.toFixed(2)}, filter=${filterFreq}Hz, reverb=${reverbWet}, vol=${volumeDb}dB`);
    }
    
    // Reset item effects (for DAW editing mode)
    function resetItemEffects() {
        if (!audioInitialized) return;
        if (effects.itemFilter) effects.itemFilter.frequency.value = 20000;
        if (effects.itemReverb) effects.itemReverb.wet.value = 0;
        if (effects.itemGain) effects.itemGain.gain.value = 1;
    }

    function randomVolume(min, max) {
        return min + Math.random() * (max - min);
    }

    function scheduleAudio(preCalculatedScore) {
        if(!audioInitialized) return;
        
        // CRITICAL: Stop Transport first to cancel all scheduled events
        Tone.Transport.cancel(); 
        Tone.Transport.stop(); 
        Tone.Transport.position = 0;
        
        // Stop all players and reset rates
        Object.values(bgPlayers).forEach(p => { 
            if(p) {
                p.stop();
                p.playbackRate = 1;
            }
        });
        
        if(samplePlayers) {
            samplePlayers.stopAll();
            Object.keys(samplePlayers._players || {}).forEach(key => {
                const player = samplePlayers.player(key);
                if(player) player.playbackRate = 1;
            });
        }
        
        console.log('🔧 V26.0 Audio reset complete');
        
        // === V26.0 SIMPLIFIED BGM: One track per mode ===
        const score = preCalculatedScore || 0;
        const scoreRatio = score / config.target;
        
        // Apply tier effects to items (not BGM)
        applyItemTierEffects(scoreRatio);
        
        // Select BGM based on mode
        const bgmPlayer = state.isTutorial ? bgPlayers.tutorial : bgPlayers.standard;
        
        if (bgmPlayer && bgmPlayer.loaded) {
            bgmPlayer.playbackRate = 1;
            bgmPlayer.volume.value = -8; // BGM is quiet background
            Tone.Transport.schedule((t) => { 
                bgmPlayer.start(t, 0).stop(t + TOTAL_DURATION); 
            }, 0);
            console.log(`▶️ V26.0 Playing ${state.isTutorial ? 'tutorial' : 'standard'} BGM`);
        }
        
        // Schedule item sounds - these are the MAIN audio content
        state.placedItems.forEach(item => {
            const start = item.start * TICK_DURATION;
            const id = item.data.id;
            
            Tone.Transport.schedule((time) => { 
                if (samplePlayers && samplePlayers.has(id)) {
                    const player = samplePlayers.player(id);
                    player.playbackRate = 1;
                    player.volume.value = -2; // Items are louder than BGM
                    player.start(time);
                }
            }, start);
        });
    }

    async function runPlaybackSequence(isSim) {
        if(state.isPlaying) return;
        state.isSimulation = !!isSim; state.isPlaying = true; isSkipping = false;
        
        // V26.0: Reset playback speed at the START of every playback
        playbackSpeed = 1;
        speedChangeTime = 0;
        positionAtSpeedChange = 0;
        Object.values(bgPlayers).forEach(p => { if(p) p.playbackRate = 1; });
        if(samplePlayers) {
            Object.keys(samplePlayers._players || {}).forEach(key => {
                const player = samplePlayers.player(key);
                if(player) player.playbackRate = 1;
            });
        }
        
        const btn = document.getElementById('mainSubmitBtn'); btn.disabled = true; btn.innerText = "Running..."; 
        document.getElementById('mainContainer').classList.add('playing-lock'); document.getElementById('skipOverlay').style.display = 'flex'; 
        document.querySelectorAll('.placed-item').forEach(el => el.classList.remove('playing-active')); 
        document.getElementById('combatConnections').innerHTML = '';
        activeBeams = [];
        activeAuras = [];

        // Reset Visuals
        document.querySelectorAll('.engine-aura').forEach(el=>el.remove());
        document.querySelectorAll('.flash-weak-fix').forEach(el=>el.classList.remove('flash-weak-fix'));

        // Pre-calculate score for 9-tier audio system
        state.lastResultData = calculateLogic();
        let totalScore = 0;
        state.lastResultData.forEach(r => {
            r.visualTriggered = false;
            totalScore += (r.base + r.bonus) * r.mult * r.finalMultiplier;
        });

        try { 
            await initAudio(); 
            Tone.Transport.stop(); 
            Tone.Transport.cancel(); 
            Tone.Draw.cancel(); 
            scheduleAudio(Math.floor(totalScore)); // Pass pre-calculated score
            Tone.Transport.start(); 
        } catch(e) { console.error('Audio error:', e); }
        
        startVisualEngine(false); 
        if (playbackTimer) clearTimeout(playbackTimer); 
        playbackTimer = setTimeout(finishPlayback, (TOTAL_DURATION * 1000) + 150);
    }

    function startVisualEngine(fastForward) {
        playbackStartTime = Date.now();
        playbackSpeed = 1; // Reset speed
        speedChangeTime = 0;
        positionAtSpeedChange = 0;
        
        const playhead = document.getElementById('playhead'); 
        if(playhead) { playhead.style.display = 'block'; playhead.style.left = '0%'; }
        if (visualInterval) clearInterval(visualInterval);
        const svg = document.getElementById('combatConnections');
        
        visualInterval = setInterval(() => {
            // Calculate current position accounting for speed changes
            let progress;
            if (playbackSpeed > 1 && speedChangeTime > 0) {
                // After speed change: position = positionAtChange + (time since change) * speed / totalDuration
                const timeSinceSpeedChange = (Date.now() - speedChangeTime) / 1000;
                progress = positionAtSpeedChange + (timeSinceSpeedChange * playbackSpeed) / TOTAL_DURATION;
            } else {
                // Normal speed
                const realElapsed = (Date.now() - playbackStartTime) / 1000;
                progress = realElapsed / TOTAL_DURATION;
            }
            progress = Math.min(progress, 1); // Cap at 100%
            
            if(playhead) playhead.style.left = (progress * 100) + "%";
            const simTime = progress * TOTAL_DURATION;
            
            // Beam Cleanup (Opacity Fade) - fade starts when target triggers
            for (let i = activeBeams.length - 1; i >= 0; i--) {
                const b = activeBeams[i];
                if (simTime >= b.fadeTime && b.el.style.opacity !== '0') {
                    b.el.style.opacity = '0';
                }
                if (simTime > b.endTime) {
                    activeBeams.splice(i, 1);
                    b.el.remove();
                }
            }
            
            // Aura Cleanup (Engine effects like Master Clock) - fade starts when target triggers
            for (let i = activeAuras.length - 1; i >= 0; i--) {
                const a = activeAuras[i];
                if (simTime >= a.fadeTime && a.el.style.opacity !== '0') {
                    a.el.style.opacity = '0'; // Start fade when target item triggers
                }
                if (simTime > a.endTime) {
                    activeAuras.splice(i, 1);
                    a.el.remove();
                }
            }

            state.lastResultData.forEach(r => {
                const start = r.record.start * TICK_DURATION; const end = start + (r.record.data.len * TICK_DURATION);
                if (r.record.el) { if (simTime >= start && simTime < end) r.record.el.classList.add('playing-active'); else r.record.el.classList.remove('playing-active'); }
                if (!r.visualTriggered && simTime >= start) {
                    r.visualTriggered = true;
                    // Show effects for score items OR support items that did something
                    const hasBuffedItems = r.buffsGiven.length > 0;
                    const hasOwnEffect = r.triggered; // Own condition triggered (e.g., Strong Beat bonus)
                    
                    if (hasBuffedItems || hasOwnEffect || r.record.data.type === 'score') {
                        const el = r.record.el;
                        if(el) {
                            const rect = el.getBoundingClientRect(); const x = rect.left + rect.width / 2; const y = rect.top;
                            if (r.record.data.type === 'score') { 
                                const score = Math.floor((r.base + r.bonus) * r.mult * r.finalMultiplier); 
                                spawnFloatingText(`+${score}`, x, y, 'ft-score'); 
                            } 
                            else if (r.record.data.type === 'support') { 
                                // Support item visual feedback based on what triggered
                                if (hasBuffedItems && hasOwnEffect) {
                                    // BEST: Both buffed items AND own condition triggered
                                    spawnFloatingText(`✨ Buff!`, x, y, 'ft-perfect');
                                    el.classList.add('support-perfect');
                                    setTimeout(() => el.classList.remove('support-perfect'), 800);
                                } else if (hasBuffedItems) {
                                    // Buffed other items
                                    spawnFloatingText(`Buff!`, x, y, 'ft-buff');
                                } else if (hasOwnEffect) {
                                    // Own condition triggered but didn't buff anyone
                                    spawnFloatingText(`✓ Active`, x, y, 'ft-active');
                                }
                            }
                            
                            if (r.record.data.id === 'SB4') { // Master Clock - each aura fades independently when target triggers
                                spawnFloatingText(`MASTER`, x, y, 'ft-buff');
                                if (r.buffsGiven.length > 0) {
                                    r.buffsGiven.forEach(b => { 
                                        const tRes = state.lastResultData[b.targetIdx]; 
                                        if(tRes && tRes.record.el) {
                                            // Each aura has independent fadeTime based on target's trigger time
                                            const targetTriggerTime = tRes.record.start * TICK_DURATION;
                                            spawnEngineEffect(tRes.record.el, 'engine-aura', targetTriggerTime);
                                        }
                                    });
                                }
                            }
                            if (r.record.data.id === 'SB5') { spawnFloatingText(`QUANTIZE`, x, y, 'ft-buff'); document.querySelectorAll('.grid-cell.cell-weak').forEach(cell => { if(cell.getBoundingClientRect().left > x) cell.classList.add('flash-weak-fix'); }); }
                            if (r.record.data.id === 'EB5') { spawnFloatingText(`STRETCH`, x, y, 'ft-buff'); document.querySelectorAll('.track').forEach(t => t.classList.add('flash-track-purple')); setTimeout(()=> document.querySelectorAll('.track').forEach(t => t.classList.remove('flash-track-purple')), 500); }
                            
                            if (r.buffsGiven.length > 0 && r.record.data.id !== 'SB4') { 
                                r.buffsGiven.forEach(b => { 
                                    if(b.type === 'consume') return; 
                                    const targetRes = state.lastResultData[b.targetIdx]; 
                                    if (targetRes && targetRes.record.el) { 
                                        // targetTime = when target item triggers
                                        const targetTriggerTime = targetRes.record.start * TICK_DURATION;
                                        drawCombatBeam(svg, el, targetRes.record.el, r.record.data.type, simTime, targetTriggerTime); 
                                    } 
                                }); 
                            }
                            const nerfs = r.logs.filter(l => l.type === 'nerf'); 
                            nerfs.forEach(n => { 
                                spawnFloatingText(n.val, x, y + 20, 'ft-neg'); 
                                const srcItem = state.placedItems.find(it => it.data.id === "NG4"); 
                                // For nerf beams, target is already triggering, so fade immediately
                                if(srcItem && srcItem.el) drawCombatBeam(svg, el, srcItem.el, 'neg', simTime, simTime); 
                            });
                        }
                    }
                }
            });
            if (progress >= 1) { clearInterval(visualInterval); if (fastForward) finishPlayback(); }
        }, 16);
    }
    
    let activeAuras = []; // Track auras for independent fade timing
    
    function spawnEngineEffect(targetEl, cls, targetTriggerTime) {
        const rect = targetEl.getBoundingClientRect(); 
        const aura = document.createElement('div'); 
        aura.className = cls; 
        aura.style.width = rect.width + 'px'; 
        aura.style.height = rect.height + 'px'; 
        aura.style.left = rect.left + 'px'; 
        aura.style.top = rect.top + 'px';
        aura.style.transition = 'opacity 0.8s ease-out';
        aura.style.opacity = '1';
        document.body.appendChild(aura);
        
        // Track aura with its target trigger time for independent fade
        if (targetTriggerTime !== undefined) {
            activeAuras.push({ el: aura, fadeTime: targetTriggerTime, endTime: targetTriggerTime + 1.0 });
        } else {
            // Fallback: remove after 2.5s if no trigger time specified
            setTimeout(() => aura.remove(), 2500);
        }
    }
    function spawnFloatingText(text, x, y, cls) { const div = document.createElement('div'); div.className = `floating-text ${cls}`; div.innerText = text; div.style.left = x + 'px'; div.style.top = y + 'px'; document.body.appendChild(div); setTimeout(() => div.remove(), 1500); }
    
    function drawCombatBeam(svg, el1, el2, type, startTime, targetTime) {
        const cRect = svg.getBoundingClientRect(); const r1 = el1.getBoundingClientRect(); const r2 = el2.getBoundingClientRect();
        const x1 = r1.left + r1.width/2 - cRect.left; const y1 = r1.top + r1.height/2 - cRect.top; const x2 = r2.left + r2.width/2 - cRect.left; const y2 = r2.top + r2.height/2 - cRect.top;
        const line = document.createElementNS('http://www.w3.org/2000/svg','line'); line.setAttribute('x1', x1); line.setAttribute('y1', y1); line.setAttribute('x2', x2); line.setAttribute('y2', y2);
        let col = type === 'neg' ? '#ff5252' : type === 'engine' ? '#d500f9' : '#00e5ff'; line.setAttribute('stroke', col); line.setAttribute('stroke-width', '4'); line.setAttribute('stroke-linecap', 'round'); 
        line.style.transition = 'opacity 0.8s ease-out'; // Fast fade when target triggers
        line.style.opacity = '1';
        svg.appendChild(line); 
        // targetTime: when target item triggers, beam starts fading
        // If targetTime <= startTime (同时触发), fade immediately
        const fadeStartTime = targetTime || startTime;
        activeBeams.push({ el: line, startTime: startTime, fadeTime: fadeStartTime, endTime: fadeStartTime + 1.0 });
    }
    
    function skipPlayback() { 
        if (isSkipping) return; 
        isSkipping = true; 
        
        // Record position when speed change happens
        const elapsed = (Date.now() - playbackStartTime) / 1000;
        positionAtSpeedChange = elapsed / TOTAL_DURATION;
        speedChangeTime = Date.now();
        playbackSpeed = 8; // 8x speed (2 seconds total)
        
        // V26.0: Speed up audio players
        Object.values(bgPlayers).forEach(p => { 
            if(p) p.playbackRate = 8;
        });
        
        // Speed up samplePlayers (item sounds)
        if(samplePlayers) {
            Object.keys(samplePlayers._players || {}).forEach(key => {
                const player = samplePlayers.player(key);
                if(player && player.state === "started") {
                    player.playbackRate = 8;
                }
            });
        }
        
        // Calculate remaining time at 8x speed
        if (playbackTimer) clearTimeout(playbackTimer);
        const remaining = Math.max(0, TOTAL_DURATION * (1 - positionAtSpeedChange));
        const fastRemaining = remaining / 8;
        
        playbackTimer = setTimeout(finishPlayback, (fastRemaining * 1000) + 100);
        
        console.log(`⏩ Fast-forward from ${(positionAtSpeedChange*100).toFixed(0)}%, remaining ${fastRemaining.toFixed(1)}s`);
    }
    
    function resetAudioEffects() {
        // V26.0: Reset all audio effects and playback rates
        resetItemEffects();
        playbackSpeed = 1;
        speedChangeTime = 0;
        positionAtSpeedChange = 0;
        Object.values(bgPlayers).forEach(p => { if(p) p.playbackRate = 1; });
        if(samplePlayers) {
            Object.keys(samplePlayers._players || {}).forEach(key => {
                const player = samplePlayers.player(key);
                if(player) player.playbackRate = 1;
            });
        }
    }
    
    function finishPlayback() {
        Tone.Transport.stop(); Tone.Transport.cancel(); 
        
        // V26.0: Stop all players and reset their playback rates
        Object.values(bgPlayers).forEach(p => { 
            if(p) {
                p.stop();
                p.playbackRate = 1;
            }
        }); 
        if(samplePlayers) {
            samplePlayers.stopAll();
            Object.keys(samplePlayers._players || {}).forEach(key => {
                const player = samplePlayers.player(key);
                if(player) player.playbackRate = 1;
            });
        }
        
        // Reset item effects
        resetItemEffects();
        
        if (visualInterval) clearInterval(visualInterval); 
        document.querySelectorAll('.placed-item').forEach(el => el.classList.remove('playing-active'));
        const playhead = document.getElementById('playhead'); 
        if(playhead) playhead.style.display = 'none'; 
        document.getElementById('skipOverlay').style.display = 'none'; 
        document.getElementById('combatConnections').innerHTML = '';
        state.isPlaying = false; 
        document.getElementById('mainContainer').classList.remove('playing-lock'); 
        document.getElementById('mainSubmitBtn').disabled = false; 
        updateSubmitButtonText(); 
        document.querySelectorAll('.engine-aura').forEach(el=>el.remove());
        activeAuras = []; 
        isSkipping = false; // Reset skip flag
        
        const results = state.lastResultData || calculateLogic(); 
        let totalScore = 0; 
        results.forEach(r => totalScore += (r.base + r.bonus) * r.mult * r.finalMultiplier);
        if (state.isSimulation) { 
            // Show full result screen for simulation (same as real submit, but with isHistoryMode = true)
            state.lastTotalScore = Math.floor(totalScore); // Save score for history
            showResult(0, state.lastTotalScore, true); 
            state.isSimulation = false; 
        } else { 
            const currentNg1Count = state.placedItems.filter(p => p.data.id === "NG1").length; 
            if (currentNg1Count > 0) { state.ng1PermanentStacks += currentNg1Count; } 
            state.lastTotalScore = Math.floor(totalScore); // Save score for history
            showResult(currentNg1Count, state.lastTotalScore); 
        }
    }

    // --- UI Logic ---
    function updateTutorialVisuals() {
        // Remove all existing soft guides first
        document.querySelectorAll('.soft-guide').forEach(el => el.classList.remove('soft-guide')); 
        document.querySelectorAll('.soft-guide-gentle').forEach(el => el.classList.remove('soft-guide-gentle'));
        
        // No soft guides in non-tutorial levels
        if (!state.isTutorial) return;
        
        // No soft guides when strong guide is active - avoid visual conflict
        if (guideState.active) return;
        
        if (state.levelIndex === 0) {
            addGuide('targetContainer');
            // FIX: Always glow inventory items until placed - support both EN/CN
            const invItems = document.querySelectorAll('.inv-item');
            const hasA = state.placedItems.some(p => p.data.id === 'TUT1');
            const hasB = state.placedItems.some(p => p.data.id === 'TUT2');
            invItems.forEach(el => { 
                const text = el.innerText;
                if ((text.includes("Sampler A") || text.includes("采样器 A")) && !hasA) addGuideGentleEl(el); 
                if ((text.includes("Sampler B") || text.includes("采样器 B")) && !hasB) addGuideGentleEl(el); 
            });
            if (state.selectedInvItem && ((state.selectedInvItem.data.id === 'TUT1' && !hasA) || (state.selectedInvItem.data.id === 'TUT2' && !hasB))) addGuideGentle('detailPanel');
        }
        if (state.levelIndex === 1) { addGuide('targetContainer'); if (!tutorialState.l2.bought) { addGuideGentle('goldText'); document.querySelectorAll('.shop-item').forEach(el => { if (el.innerText.includes("Rest") || el.innerText.includes("休止")) addGuideGentleEl(el); }); } else if (!tutorialState.l2.effectActive) { document.querySelectorAll('.inv-item').forEach(el => { if (el.innerText.includes("Rest") || el.innerText.includes("休止")) addGuideGentleEl(el); }); if (state.selectedInvItem && state.selectedInvItem.data.id === 'EB1') addGuideGentle('detailPanel'); } }
        if (state.levelIndex === 2) { addGuide('targetContainer'); const needKick = !tutorialState.l3.kickBought; const needCpu = !tutorialState.l3.cpuBought; if (needKick || needCpu) { addGuideGentle('goldText'); if (needCpu) addGuide('btnBuyCpu'); if (needKick) document.querySelectorAll('.shop-item').forEach(el => { if (el.innerText.includes("Kick") || el.innerText.includes("底鼓")) addGuideGentleEl(el); }); } else if (!tutorialState.l3.kickEffect) { document.querySelectorAll('.inv-item').forEach(el => { if (el.innerText.includes("Kick") || el.innerText.includes("底鼓")) addGuideGentleEl(el); }); if (state.selectedInvItem && state.selectedInvItem.data.id === 'SB1') addGuideGentle('detailPanel'); } }
        // Level 4: No soft guides - we use strong guides now (sell both + buy 3 CPU)
    }
    function addGuide(id) { const el = document.getElementById(id); if (el) el.classList.add('soft-guide'); }
    function addGuideGentle(id) { const el = document.getElementById(id); if (el) el.classList.add('soft-guide-gentle'); }
    function addGuideGentleEl(el) { if(el) el.classList.add('soft-guide-gentle'); }
    function canSell() { return !state.isTutorial || state.levelIndex >= 3; }

    function startDragInventory(e, invItem) { if(state.isPlaying) return; if(e.button !== 0) return; e.stopPropagation(); setupDrag(e, invItem.data, 'inventory', null, invItem); }
    function startDragPlaced(e, record) { if(state.isPlaying) return; if(e.button !== 0) return; e.stopPropagation(); record.el.classList.add('item-being-dragged'); setupDrag(e, record.data, 'track', record, null); }
    function setupDrag(e, itemData, type, record, invItem) {
        dragManager.active = true; dragManager.itemData = itemData; dragManager.sourceType = type; dragManager.sourceRecord = record; dragManager.sourceInvItem = invItem;
        dragManager.startX = e.clientX; dragManager.startY = e.clientY;
        const ghost = document.createElement('div'); ghost.className = 'drag-ghost'; ghost.innerText = itemData.name[state.lang]; ghost.style.backgroundColor = itemData.color;
        const trackW = document.querySelector('.track').getBoundingClientRect().width; const widthPx = (trackW / TICKS) * itemData.len; ghost.style.width = widthPx + 'px'; ghost.style.height = '40px'; 
        document.body.appendChild(ghost); dragManager.ghostEl = ghost;
        if (state.isTutorial && state.levelIndex === 0) document.getElementById('trackArea').classList.add('dragging-mode');
        if (type === 'inventory' && canSell()) document.getElementById('shopPanel').classList.add('sell-hint');
        updateGhostPosition(e.clientX, e.clientY);
        if(type === 'inventory') { state.selectedInvItem = invItem; updateInventoryUI(); showDetail(invItem.data); } else { state.selectedInvItem = null; showDetail(record.data); }
    }
    function onGlobalDragMove(e) {
        if (!dragManager.active) return; e.preventDefault(); updateGhostPosition(e.clientX, e.clientY); updateCPU(); 
        
        // Calculate grid position based on ghost's LEFT edge (not mouse center)
        // Ghost is centered on mouse, so left edge = mouseX - ghostWidth/2
        const ghostWidth = dragManager.ghostEl ? dragManager.ghostEl.offsetWidth : 0;
        const ghostLeftX = e.clientX - ghostWidth / 2;
        
        const gridPos = getGridFromClient(ghostLeftX, e.clientY); clearPreview();
        if (gridPos) {
            const isValid = checkPlacementValidity(gridPos.track, gridPos.tick, dragManager.itemData); renderPreview(gridPos.track, gridPos.tick, dragManager.itemData.len, isValid);
            dragManager.currentHover = gridPos; dragManager.hoverType = 'track'; if(dragManager.sellTooltip) { dragManager.sellTooltip.remove(); dragManager.sellTooltip = null; }
        } else {
            const shopPanel = document.getElementById('shopPanel'); const rect = shopPanel.getBoundingClientRect();
            if (e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom) {
                if (dragManager.sourceType === 'inventory' && canSell()) {
                    shopPanel.classList.add('drag-target-sell'); dragManager.hoverType = 'shop';
                    if (!dragManager.sellTooltip) { const tooltip = document.createElement('div'); tooltip.className = 'drag-sell-tooltip'; document.body.appendChild(tooltip); dragManager.sellTooltip = tooltip; }
                    const item = dragManager.sourceInvItem; const price = item.boughtPrice === 0 ? 25 : Math.floor(item.boughtPrice * 0.25);
                    dragManager.sellTooltip.innerText = `${UI_TEXT[state.lang].sell}: +${price}G`; dragManager.sellTooltip.style.left = (e.clientX + 20) + 'px'; dragManager.sellTooltip.style.top = (e.clientY - 20) + 'px';
                }
            } else {
                shopPanel.classList.remove('drag-target-sell'); dragManager.hoverType = 'outside'; if(dragManager.sellTooltip) { dragManager.sellTooltip.remove(); dragManager.sellTooltip = null; }
            }
            dragManager.currentHover = null;
        }
    }
    function onGlobalDragEnd(e) {
        if (!dragManager.active) return;
        const { itemData, sourceType, sourceRecord, sourceInvItem, hoverType, currentHover } = dragManager;
        if (dragManager.ghostEl) dragManager.ghostEl.remove(); if (dragManager.sellTooltip) dragManager.sellTooltip.remove(); dragManager.sellTooltip = null; clearPreview();
        document.getElementById('trackArea').classList.remove('dragging-mode'); document.getElementById('shopPanel').classList.remove('sell-hint'); document.getElementById('shopPanel').classList.remove('drag-target-sell');
        if (sourceRecord && sourceRecord.el) sourceRecord.el.classList.remove('item-being-dragged');
        if (hoverType === 'track' && currentHover) {
            if (checkPlacementValidity(currentHover.track, currentHover.tick, itemData)) {
                if (sourceType === 'track') state.placedItems = state.placedItems.filter(p => p !== sourceRecord);
                state.placedItems.push({ id: Date.now(), data: itemData, track: currentHover.track, start: currentHover.tick });
                restorePlacedItems();
                // Tutorial guide: item placed
                checkGuideAction('place');
            }
        } else if (hoverType === 'shop' && sourceType === 'inventory') { if (canSell()) { state.selectedInvItem = sourceInvItem; sellSelectedItem(); } }
        else if (hoverType === 'outside' && sourceType === 'track') { state.placedItems = state.placedItems.filter(p => p !== sourceRecord); restorePlacedItems(); }
        dragManager.active = false; dragManager.ghostEl = null; updateCPU(); updateUI();
        
        // Re-highlight sampler items if guide is still waiting for sellBoth
        if (guideState.active && guideState.waitingFor === 'sellBoth') {
            setTimeout(() => {
                clearGuideHighlight();
                highlightSamplerItems();
            }, 50);
        }
    }
    function getGridFromClient(cx, cy) {
        const tracks = document.querySelectorAll('.track'); for (let i = 0; i < tracks.length; i++) { const rect = tracks[i].getBoundingClientRect(); if (cy >= rect.top && cy <= rect.bottom && cx >= rect.left && cx <= rect.right) { if (i >= config.activeTracks) return null; const xInTrack = cx - rect.left; const widthPerTick = rect.width / TICKS; let tick = Math.floor(xInTrack / widthPerTick); if (tick < 0) tick = 0; if (tick >= TICKS) tick = TICKS - 1; return { track: i, tick: tick }; } } return null;
    }
    function checkPlacementValidity(trackIdx, startTick, itemData) {
        if (trackIdx >= state.unlockedTracks) return false;
        if (startTick + itemData.len > TICKS) return false;
        if (dragManager.sourceType === 'inventory') { if (state.placedItems.reduce((a,b)=>a+b.data.cpu, 0) + itemData.cpu > config.maxCpu) return false; }
        
        // UNIQUE CHECK
        if (itemData.unique) {
            const existing = state.placedItems.find(p => p.data.id === itemData.id && p !== dragManager.sourceRecord);
            if (existing) return false;
        }

        const others = state.placedItems.filter(p => p !== dragManager.sourceRecord);
        for (let item of others) { if (item.track === trackIdx) { if (Math.max(item.start, startTick) < Math.min(item.start + item.data.len, startTick + itemData.len)) return false; } } return true;
    }
    function renderPreview(trackIdx, startTick, len, isValid) { const trackEl = document.querySelectorAll('.track')[trackIdx]; if (!trackEl) return; const preview = document.createElement('div'); preview.className = isValid ? 'drag-preview-valid' : 'drag-preview-invalid'; preview.style.position = 'absolute'; preview.style.height = '100%'; preview.style.left = (startTick / TICKS * 100) + '%'; preview.style.width = (len / TICKS * 100) + '%'; trackEl.appendChild(preview); dragManager.previewEl = preview; }
    function clearPreview() { if (dragManager.previewEl) { dragManager.previewEl.remove(); dragManager.previewEl = null; } }
    function updateGhostPosition(x, y) { if (dragManager.ghostEl) { dragManager.ghostEl.style.left = x + 'px'; dragManager.ghostEl.style.top = y + 'px'; } }

    function toggleLanguage() { state.lang = (state.lang === 'en') ? 'cn' : 'en'; updateAllText(); }
    function showHelpModal() { document.getElementById('helpModal').style.display = 'flex'; }
    function closeHelpModal() { document.getElementById('helpModal').style.display = 'none'; }
    function updateAllText() {
        const t = UI_TEXT[state.lang];
        ['txtClear','lblCpu','lblTarget','lblInventory','lblShop','txtUpCpu','txtHistory'].forEach(id => { const el = document.getElementById(id); if(el) el.innerText = t[id.replace('txt','').replace('lbl','').toLowerCase()] || t[id.toLowerCase()]; });
        document.getElementById('btnReroll').innerText = `${t.reroll} (10G)`; document.getElementById('detailTitle').innerText = t.ready; document.getElementById('detailContent').innerHTML = t.readyDesc;
        document.getElementById('lblLevel').innerText = t.level; document.getElementById('lblTracks').innerText = t.tracks;
        // V26.0: Tutorial 1-3 shows "视听/PREVIEW", Tutorial 4+ and Standard shows "提交/SUBMIT"
        updateSubmitButtonText();
        document.getElementById('txtStartMsg').innerText = t.startTitle; document.getElementById('btnStartGame').innerText = t.startGame; document.getElementById('resTitle').innerText = t.report;
        document.getElementById('lblResTarget').innerText = t.resTarget; document.getElementById('lblResTotal').innerText = t.resTotal; document.getElementById('nextLevelBtn').innerText = t.nextLevel;
        document.getElementById('finishGameBtn').innerText = t.victory; document.getElementById('retryLevelBtn').innerText = t.retry; document.getElementById('dieBtn').innerText = t.acceptFate;
        document.getElementById('txtWinTitle').innerText = t.youWin; document.getElementById('txtWinMsg').innerText = t.winMsg; document.getElementById('btnRestart1').innerText = t.playAgain;
        document.getElementById('txtLoseTitle').innerText = t.gameOver; document.getElementById('txtLoseMsg').innerText = t.loseMsg; document.getElementById('btnRestart2').innerText = t.tryAgain;
        document.getElementById('lblHelpTitle').innerText = t.helpTitle; document.getElementById('lblHelpControl').innerText = t.helpControlTitle; document.getElementById('txtHelpControl').innerHTML = t.helpControlTxt;
        document.getElementById('lblTutTitle').innerText = t.tutTitle; document.getElementById('lblTutDesc').innerText = t.tutDesc; document.getElementById('btnSkipTut').innerText = t.skip;
        document.getElementById('btnPlayTut').innerText = t.playTut; document.getElementById('lblTutCompDesc').innerText = t.tutCompDesc;
        document.querySelector('#simBtn span').innerText = t.simulate;
        // Confirm Submit Modal
        document.getElementById('txtConfirmTitle').innerText = t.confirmTitle;
        document.getElementById('txtConfirmMsg').innerText = t.confirmMsg;
        document.getElementById('txtConfirmWarning').innerText = t.confirmWarning;
        document.getElementById('btnCancelSubmit').innerText = t.confirmCancel;
        document.getElementById('btnConfirmSubmit').innerText = t.confirmSubmit;
        // Discord Modal
        document.getElementById('txtDiscordMsg').innerText = t.discordMsg;
        document.getElementById('txtScanQR').innerText = t.scanQR;
        document.getElementById('txtJoinDiscord').innerText = t.joinDiscord;
        document.getElementById('btnDiscordContinue').innerText = t.discordContinue;
        updateInventoryUI(); renderShopFromState(); updateCpuButton(); updateSimButton();
        if(state.selectedInvItem) showDetail(state.selectedInvItem.data);
    }
    function showTooltip(e, key) { const tip = document.getElementById('tooltip'); const defs = DEFINITIONS[state.lang]; if(tip && defs[key]) { tip.style.display = 'block'; tip.style.left = (e.clientX + 10) + 'px'; tip.style.top = (e.clientY + 10) + 'px'; tip.innerHTML = `<span class="tooltip-key">[${key}]</span>${defs[key]}`; } }
    function hideTooltip() { const tip = document.getElementById('tooltip'); if(tip) tip.style.display = 'none'; }
    function showLangSelect() { document.getElementById('startScreen').style.display = 'none'; document.getElementById('langSelectModal').style.display = 'flex'; }
    function selectLang(lang) { state.lang = lang; updateAllText(); document.getElementById('langSelectModal').style.display = 'none'; document.getElementById('tutorialQueryModal').style.display = 'flex'; }
    function skipTutorial() { document.getElementById('tutorialQueryModal').style.display = 'none'; startStandardGame(); }
    function playTutorial() { document.getElementById('tutorialQueryModal').style.display = 'none'; state.isTutorial = true; startTutorialLevel(0); }
    function startStandardGame() { 
        // Check if player earned Pad (EB6) from tutorial before clearing inventory
        const hasPadFromTutorial = tutorialState.l4.padGiven && state.inventory.some(i => i.data.id === 'EB6');
        
        state.isTutorial = false; 
        state.inventory = []; 
        state.ng1PermanentStacks = 0; 
        state.milestoneProgress = 0; 
        state.gold = 150; 
        ["SB1", "EB1", "NG2"].forEach(id => addItemToInventory(id, 0)); 
        
        // Add Pad if earned from tutorial
        if (hasPadFromTutorial) {
            addItemToInventory('EB6', 0);
        }
        
        config.maxCpu = 12; 
        state.placedItems = []; 
        applyLevelConfig(0); 
        updateUI(); 
    }
    function startTutorialLevel(idx, isRetry = false) { 
        state.levelIndex = idx; 
        resetTutorialStateForLevel(idx); 
        const cfg = TUTORIAL_CONFIG[idx]; 
        config.target = cfg.target; 
        config.activeTracks = cfg.tracks; 
        if (idx === 0) { 
            state.inventory = []; state.placedItems = []; state.poolIds = []; state.gold = 0; 
            config.maxCpu = cfg.startCpu; 
            if(cfg.initialItems) cfg.initialItems.forEach(id => addItemToInventory(id, 0)); 
        } 
        if (cfg.poolAdds) cfg.poolAdds.forEach(id => { 
            if(!state.poolIds.includes(id)) state.poolIds.push(id); 
            if (!state.poolEntryTimes[id]) state.poolEntryTimes[id] = 0; 
        }); 
        state.tutorialCpuBought = false; 
        if(cfg.repeatableCpu) state.cpuPurchasedRound = 0; 
        applyLevelConfig(idx); 
        if (idx > 0) forceTutorialShop(idx, isRetry); 
        else { state.currentShopItems = []; renderShopFromState(); }
        // V26.0: Update submit button text
        updateSubmitButtonText();
        // Start strong guide after a short delay (only if not retry)
        if (!isRetry) setTimeout(() => startLevelGuide(idx), 500);
    }
    function forceTutorialShop(idx, isRetry = false) { 
        state.currentShopItems = []; 
        const cfg = TUTORIAL_CONFIG[idx]; 
        
        // For level 4 retry: Check for sold essential items and add them to shop
        if (idx === 3 && isRetry) {
            const essentialItems = ['EB4', 'SB1', 'EB1']; // Pre-Delay, Kick, Rest
            essentialItems.forEach(id => {
                if (!state.inventory.some(inv => inv.data.id === id)) {
                    const data = DB.find(i => i.id === id);
                    if (data) {
                        state.currentShopItems.push({ 
                            data: data, 
                            price: data.price, 
                            isDiscount: false, 
                            discountPercent: 0, 
                            sold: false 
                        });
                    }
                }
            });
        }
        
        if (cfg.poolAdds) cfg.poolAdds.forEach(id => { 
            if (!state.inventory.some(inv => inv.data.id === id)) { 
                const data = DB.find(i => i.id === id); 
                if(data) state.currentShopItems.push({ data: data, price: data.price, isDiscount: false, discountPercent: 0, sold: false }); 
            } 
        }); 
        renderShopFromState(); 
    }
    function addItemToInventory(id, price) { const data = DB.find(i => i.id === id); if(data) state.inventory.push({ uid: Date.now()+Math.random(), id: id, boughtPrice: price, data: data }); }
    
    function applyLevelConfig(idx) { 
        if (idx >= LEVEL_CONFIG.length && !state.isTutorial) return; 
        state.levelIndex = idx; 
        const cfg = state.isTutorial ? TUTORIAL_CONFIG[idx] : LEVEL_CONFIG[idx]; 
        config.target = cfg.target; 
        config.activeTracks = cfg.tracks; 
        
        // Track Logic V23.5: Std Mode starts with 2 unlocked
        if (!state.isTutorial && idx === 0) state.unlockedTracks = 2; 
        else if (idx === 0) state.unlockedTracks = 1;
        else if (state.isTutorial && idx === 3) {
            // Tutorial L4: If player already unlocked track 2, keep it unlocked on retry
            state.unlockedTracks = tutorialState.l4.trackUnlocked ? 2 : 1;
        }
        else if (!state.isTutorial && idx === 2) state.unlockedTracks = 2; 
        else state.unlockedTracks = config.activeTracks; 

        state.cpuPurchasedRound = 0; state.roundBase = 10 + (idx * 2); 
        // Tutorial L4 uses same base as Std L1 (10)
        if (state.isTutorial && idx === 3) state.roundBase = 10; 

        if (!state.isTutorial && cfg.poolAdds) cfg.poolAdds.forEach(id => { if(!state.poolIds.includes(id)) state.poolIds.push(id); if (!state.poolEntryTimes[id]) state.poolEntryTimes[id] = idx; }); 
        updateUI(); initGrid(); restorePlacedItems(); if(!state.isTutorial) rerollShop(); 
    }

    function updateUI() { 
        document.getElementById('levelNum').innerText = `${state.levelIndex + 1}`; 
        document.getElementById('trackNum').innerText = config.activeTracks; 
        document.getElementById('maxCpuText').innerText = `Max: ${config.maxCpu}`; 
        document.getElementById('targetText').innerText = config.target; 
        document.getElementById('goldText').innerText = state.gold + " G"; 
        updateInventoryUI(); updateCpuButton(); updateSimButton(); updateCPU(); 
        document.getElementById('btnReroll').style.display = state.isTutorial ? 'none' : 'block';
        
        // Update tier display (show only in tutorial L4+ or standard mode)
        const tierContainer = document.getElementById('tierContainer');
        if (tierContainer) {
            const showTiers = !state.isTutorial || state.levelIndex >= 3;
            tierContainer.style.display = showTiers ? 'block' : 'none';
            if (showTiers) {
                const target = config.target;
                document.getElementById('tier1Score').innerText = target;
                document.getElementById('tier2Score').innerText = Math.ceil(target * 1.10);
                document.getElementById('tier3Score').innerText = Math.ceil(target * 1.25);
            }
        }
    }
    function updateGold(amount, animationTargetId) { state.gold += amount; document.getElementById('goldText').innerText = state.gold + " G"; if (amount < 0 && animationTargetId) { const target = document.getElementById(animationTargetId); if(target) { const float = document.createElement('div'); float.innerText = `${amount}G`; float.className = 'float-text'; float.style.color = '#ff5252'; const rect = target.getBoundingClientRect(); float.style.left = (rect.left + rect.width/2) + 'px'; float.style.top = rect.top + 'px'; document.body.appendChild(float); setTimeout(()=>float.remove(), 1000); } } updateSimButton(); updateCpuButton(); }
    function updateCpuButton() { const btn = document.getElementById('btnBuyCpu'); if (state.isTutorial && state.levelIndex < 2) { btn.style.display = 'none'; return; } else { btn.style.display = 'flex'; } if (state.isTutorial && state.levelIndex === 2) { if (state.tutorialCpuBought) { btn.disabled = true; document.getElementById('txtUpCpu').innerText = UI_TEXT[state.lang].soldOutQAQ; document.getElementById('cpuPriceText').innerText = ""; return; } else { btn.disabled = false; document.getElementById('txtUpCpu').innerText = UI_TEXT[state.lang].upCpu; document.getElementById('cpuPriceText').innerText = "30G"; return; } } btn.disabled = false; document.getElementById('txtUpCpu').innerText = UI_TEXT[state.lang].upCpu; const cost = 30 + (Math.min(state.cpuPurchasedRound, 2) * state.roundBase); document.getElementById('cpuPriceText').innerText = `${cost}G`; }
    function updateSimButton() { const btn = document.getElementById('simBtn'); if (state.isTutorial && state.levelIndex < 3) { btn.style.display = 'none'; return; } document.getElementById('simCostText').style.display = 'none'; if (state.isPlaying) btn.disabled = true; else btn.disabled = false; btn.style.display = 'flex'; }
    function updateCPU() { const used = state.placedItems.reduce((a, b) => a + b.data.cpu, 0); const max = config.maxCpu; const usedPct = Math.min(100, (used / max) * 100); const bar = document.getElementById('cpuBar'); const previewBar = document.getElementById('cpuPreviewBar'); if (!previewBar) return; if (dragManager.active && dragManager.sourceType === 'inventory' && dragManager.itemData) { const itemCost = dragManager.itemData.cpu; const projectedTotal = used + itemCost; const previewWidthPct = (itemCost / max) * 100; previewBar.style.left = usedPct + "%"; previewBar.style.width = previewWidthPct + "%"; previewBar.style.display = 'block'; if (projectedTotal > max) { previewBar.className = "cpu-preview invalid"; if (bar) bar.className = "cpu-fill overload"; document.getElementById('cpuText').style.color = '#ff5252'; document.getElementById('cpuText').innerText = `${used} + ${itemCost}`; } else { previewBar.className = "cpu-preview valid"; if (bar) bar.className = "cpu-fill " + (used >= max ? "danger" : ""); document.getElementById('cpuText').style.color = '#ffd700'; document.getElementById('cpuText').innerText = `${used} + ${itemCost}`; } } else { previewBar.style.display = 'none'; if (bar) bar.className = "cpu-fill " + (used >= max ? "danger" : ""); document.getElementById('cpuText').style.color = '#ccc'; document.getElementById('cpuText').innerText = `${used}`; } if (bar) bar.style.width = usedPct + "%"; }
    
    function initGrid() { 
        const rh = document.querySelector('.timeline-header'); 
        if(rh) { rh.innerHTML = ''; for(let i=0; i<8; i++) { let d = document.createElement('div'); d.className = 'ruler-beat'; d.innerText = `${Math.floor(i/4)+1}.${(i%4)+1}`; rh.appendChild(d); } } 
        const ta = document.getElementById('trackArea'); 
        if(ta) { 
            const oldSvg = document.getElementById('combatConnections');
            ta.innerHTML = ''; 
            let ph = document.createElement('div'); ph.id = 'playhead'; ph.className = 'playhead'; ta.appendChild(ph); 
            if(oldSvg) ta.appendChild(oldSvg); else { let s = document.createElementNS("http://www.w3.org/2000/svg", "svg"); s.id="combatConnections"; s.classList.add("combat-overlay"); ta.appendChild(s); }

            for(let i=0; i<TOTAL_TRACKS; i++) { 
                let tr = document.createElement('div'); tr.className = 'track'; 
                
                // Track Logic
                if (i >= state.unlockedTracks) {
                    if (i < config.activeTracks) { 
                        let overlay = document.createElement('div');
                        overlay.className = 'track-lock-overlay shake-hint';
                        overlay.innerHTML = `<span class="lock-icon">🔒</span>`;
                        overlay.onclick = () => unlockTrack(i);
                        tr.appendChild(overlay);
                    } else { 
                        tr.classList.add('hard-locked');
                    }
                }

                for(let t=0; t<TICKS; t++) { let c = document.createElement('div'); c.className = 'grid-cell'; const beatIndex = Math.floor(t / 4); if (beatIndex % 2 === 0) c.classList.add('cell-strong'); else c.classList.add('cell-weak'); tr.appendChild(c); } 
                ta.appendChild(tr); 
            } 
        } 
    }

    function unlockTrack(idx) {
        if (idx !== state.unlockedTracks) return; 
        const overlay = document.querySelectorAll('.track-lock-overlay')[0];
        if(overlay) {
            overlay.classList.add('unlocking');
            setTimeout(() => {
                state.unlockedTracks++;
                // Remember that track was unlocked in tutorial L4
                if (state.isTutorial && state.levelIndex === 3) {
                    tutorialState.l4.trackUnlocked = true;
                }
                initGrid();
                restorePlacedItems();
            }, 600);
        }
    }

    function clearAllItems() { if(state.isPlaying) return; if(!confirm("Clear all items?")) return; state.placedItems = []; restorePlacedItems(); }
    function restorePlacedItems() { const ta = document.getElementById('trackArea'); const items = ta.querySelectorAll('.placed-item'); items.forEach(e => e.remove()); state.placedItems.forEach(record => { const trEl = document.getElementsByClassName('track')[record.track]; if (trEl) createPlacedElement(record, trEl); }); updateRealTimeState(); }
    function createPlacedElement(record, parent) { let el = document.createElement('div'); el.className = 'placed-item'; if (record.data.type) el.classList.add('type-' + record.data.type); el.style.left = (record.start/TICKS*100) + "%"; el.style.width = (record.data.len/TICKS*100) + "%"; el.style.backgroundColor = record.data.color; el.innerText = record.data.name[state.lang]; el.onmousedown = (e) => startDragPlaced(e, record); el.oncontextmenu = (e) => { if(state.isPlaying) return; e.preventDefault(); el.remove(); state.placedItems = state.placedItems.filter(x => x !== record); updateRealTimeState(); }; parent.appendChild(el); record.el = el; }
    function updateInventoryUI() { const list = document.getElementById('inventoryList'); list.innerHTML = ''; state.inventory.forEach(item => { let d = document.createElement('div'); d.className = 'inv-item'; d.setAttribute('data-id', item.data.id); d.style.borderLeftColor = item.data.color; if(state.selectedInvItem === item) d.classList.add('selected'); if(state.isPlaying) d.classList.add('disabled'); d.innerHTML = `<b style="color:${item.data.color}">${item.data.name[state.lang]}</b><div class="inv-meta"><span>CPU:${item.data.cpu}</span><span>Len:${item.data.len}</span></div>`; d.onmousedown = (e) => startDragInventory(e, item); list.appendChild(d); }); }
    
    function runSimulation() { 
        checkGuideAction('simulate'); 
        runPlaybackSequence(true); 
    }
    
    // === V26.0 SUBMIT SYSTEM ===
    // Tutorial 1-3: "视听" mode - preview only, auto-advance if score met
    // Tutorial 4 + Standard: Enter Performance Stage
    function trySubmit() {
        if (state.isPlaying) return;
        
        if (state.isTutorial) {
            if (state.levelIndex <= 2) {
                // Tutorial 1-3: Preview mode (视听)
                // Play audio and show score, auto-advance if target met
                runTutorialPreview();
            } else {
                // Tutorial 4: Enter Performance Stage
                // Must simulate first
                const simScore = tutorialState.l4.simScore;
                if (simScore === null || simScore < config.target) {
                    showSimRequired();
                    return;
                }
                enterPerformanceStage();
            }
        } else {
            // Standard mode: confirmation then Performance Stage
            document.getElementById('confirmSubmitModal').style.display = 'flex';
        }
    }
    
    function cancelSubmit() {
        document.getElementById('confirmSubmitModal').style.display = 'none';
    }
    
    function confirmSubmit() {
        document.getElementById('confirmSubmitModal').style.display = 'none';
        enterPerformanceStage();
    }
    
    // Tutorial 1-3: Preview mode - now uses full simulation like normal mode
    async function runTutorialPreview() {
        // Use the same simulation flow as normal mode
        // This allows fast-forward, result screen, and history viewing
        checkGuideAction('simulate');
        
        // Mark as simulation so it shows result screen
        state.isSimulation = true;
        state.tutorialPreviewMode = true; // Special flag for tutorial preview
        
        runPlaybackSequence(true); // true = simulation mode
    }
    
    // Called when tutorial preview finishes (from finishPlayback -> showResult)
    // We override the result behavior for tutorial 1-3
    function handleTutorialPreviewResult(totalScore) {
        const isWin = totalScore >= config.target;
        
        if (isWin) {
            // Auto advance after player closes result
            state.pendingTutorialAdvance = true;
            state.pendingReward = TUTORIAL_CONFIG[state.levelIndex].reward;
        }
    }
    
    // Show floating text on main screen
    function showFloatText(text, color) {
        const float = document.createElement('div');
        float.className = 'floating-text';
        float.innerText = text;
        float.style.color = color;
        float.style.left = '50%';
        float.style.top = '40%';
        float.style.transform = 'translateX(-50%)';
        float.style.fontSize = '28px';
        document.body.appendChild(float);
        setTimeout(() => float.remove(), 1500);
    }
    
    // V26.0: Update submit button text based on mode
    function updateSubmitButtonText() {
        const btn = document.getElementById('mainSubmitBtn');
        if (!btn) return;
        
        if (state.isTutorial && state.levelIndex <= 2) {
            // Tutorial 1-3: Preview mode
            btn.innerText = state.lang === 'cn' ? '视听' : 'PREVIEW';
        } else {
            // Tutorial 4+ and Standard: Submit mode
            btn.innerText = state.lang === 'cn' ? '提交' : 'SUBMIT';
        }
    }
    
    // Enter Performance Stage
    function enterPerformanceStage() {
        showPerformanceStage();
        
        // Start playback after a short delay
        setTimeout(() => {
            startStagePlayback();
        }, 500);
    }
    
    // Tutorial L4: Simulate required modal
    function showSimRequired() {
        const t = UI_TEXT[state.lang];
        document.getElementById('txtSimRequiredTitle').innerText = state.lang === 'cn' ? '需要先模拟' : 'Simulate First';
        document.getElementById('txtSimRequiredMsg').innerText = state.lang === 'cn' 
            ? '提交前必须先进行模拟，且模拟分数需要达到目标分数才能提交。' 
            : 'Before submitting, you must simulate your build and achieve a score that meets or exceeds the target score.';
        document.getElementById('txtSimRequiredWarning').innerText = state.lang === 'cn' 
            ? '使用"试听"按钮来测试你的组合！' 
            : 'Use the SIMULATE button to test your build!';
        document.getElementById('btnSimRequiredOK').innerText = state.lang === 'cn' ? '知道了' : 'Got it';
        document.getElementById('simRequiredModal').style.display = 'flex';
    }
    function closeSimRequired() {
        document.getElementById('simRequiredModal').style.display = 'none';
    }
    
    function showHistory() { 
        if (!state.lastResultData || state.lastTotalScore === 0) { 
            alert(state.lang === 'cn' ? "暂无历史记录。" : "No history available yet."); 
            return; 
        } 
        // Restore the last result layout and score
        showResult(0, state.lastTotalScore, true); 
    }
    
    // Grant milestone reward (rare item or +3 CPU if all collected)
    function grantMilestoneReward() {
        // Find rare items player doesn't have
        const ownedIds = state.inventory.map(i => i.data.id);
        const availableRare = RARE_ITEM_POOL.filter(id => !ownedIds.includes(id));
        
        if (availableRare.length > 0) {
            // Grant random rare item
            const randomId = availableRare[Math.floor(Math.random() * availableRare.length)];
            addItemToInventory(randomId, 0);
            const itemData = DB.find(i => i.id === randomId);
            return itemData ? itemData.name[state.lang] : randomId;
        } else {
            // All rare items collected, give +3 CPU instead
            config.maxCpu += 3;
            return state.lang === 'cn' ? '+3 CPU' : '+3 CPU';
        }
    }

    function renderResultGrid(results) {
        const container = document.getElementById('resTrackArea'); container.innerHTML = '';
        const svg = document.getElementById('resConnections'); svg.innerHTML = '';
        
        for(let i=0; i<config.activeTracks; i++) {
            let row = document.createElement('div'); row.className = 'res-grid-row';
            let bg = document.createElement('div'); bg.className = 'res-grid-bg';
            for(let t=0; t<TICKS; t++) { let c = document.createElement('div'); c.className = 'res-grid-cell'; bg.appendChild(c); }
            row.appendChild(bg); container.appendChild(row);
        }
        const rows = document.querySelectorAll('.res-grid-row');
        results.forEach((r, idx) => {
            let el = document.createElement('div'); el.className = 'res-item'; el.style.left = (r.record.start/TICKS*100) + "%"; el.style.width = (r.record.data.len/TICKS*100) + "%"; el.style.backgroundColor = r.record.data.color;
            const totalScore = Math.floor((r.base + r.bonus) * r.mult * r.finalMultiplier); el.innerHTML = r.record.data.type === 'score' ? `+${totalScore}` : r.record.data.type === 'support' ? `Buff` : `Engine`;
            el.onmouseenter = () => highlightRelations(idx, results, svg, container); el.onmouseleave = () => clearRelations(svg, container);
            rows[r.record.track].appendChild(el); r.resEl = el;
        });
        
        // V23.5: Persistent Faint Lines
        drawAllFaintLines(results, svg, container);
    }
    
    function drawAllFaintLines(results, svg, container) {
        results.forEach((target, idx) => {
            target.logs.forEach(log => {
                if (log.srcIdx !== undefined && results[log.srcIdx]) {
                    const src = results[log.srcIdx];
                    if(src.resEl && target.resEl) drawSVGLine(svg, container, src.resEl, target.resEl, 'rgba(0, 229, 255, 0.2)', false);
                }
            });
        });
    }

    function highlightRelations(idx, results, svg, container) {
        clearRelations(svg, container); const target = results[idx]; if(!target.resEl) return; target.resEl.classList.add('highlight-target');
        
        // Incoming (Who buffed me?)
        target.logs.forEach(log => { if (log.srcIdx !== undefined && results[log.srcIdx]) { const src = results[log.srcIdx]; if(src.resEl) { src.resEl.classList.add('highlight-source'); drawSVGLine(svg, container, src.resEl, target.resEl, '#00e5ff', true); } } });
        
        // Outgoing (Who did I buff?) -- V23.5
        if (target.buffsGiven && target.buffsGiven.length > 0) {
            target.buffsGiven.forEach(b => {
                const dest = results[b.targetIdx];
                if (dest && dest.resEl) {
                    dest.resEl.classList.add('highlight-source'); // Reusing source style for target just to highlight
                    drawSVGLine(svg, container, target.resEl, dest.resEl, '#d500f9', true);
                }
            });
        }

        showResultTooltip(target);
    }
    function clearRelations(svg, container) { 
        svg.innerHTML = ''; 
        const results = state.lastResultData || []; 
        drawAllFaintLines(results, svg, container);
        container.querySelectorAll('.res-item').forEach(el => el.classList.remove('highlight-target', 'highlight-source')); 
        document.getElementById('resultTooltip').style.display = 'none'; 
    }
    function drawSVGLine(svg, container, el1, el2, color, isDashed) {
        const cRect = container.getBoundingClientRect(); const r1 = el1.getBoundingClientRect(); const r2 = el2.getBoundingClientRect();
        const x1 = r1.left + r1.width/2 - cRect.left; const y1 = r1.top + r1.height/2 - cRect.top; const x2 = r2.left + r2.width/2 - cRect.left; const y2 = r2.top + r2.height/2 - cRect.top;
        const line = document.createElementNS('http://www.w3.org/2000/svg','line'); line.setAttribute('x1', x1); line.setAttribute('y1', y1); line.setAttribute('x2', x2); line.setAttribute('y2', y2); line.setAttribute('stroke', color); line.setAttribute('stroke-width', '2'); 
        if(isDashed) line.setAttribute('stroke-dasharray', '5,5'); 
        svg.appendChild(line);
    }
    
    // Updated Tooltip Logic V27.0 - Clear effect breakdown
    function showResultTooltip(r) {
        const tip = document.getElementById('resultTooltip'); const t = UI_TEXT[state.lang];
        const itemName = r.record.data.name[state.lang];
        let html = `<b>${itemName}</b><br>`; 
        
        // For score items, always show base first
        if (r.record.data.type === 'score' && r.base > 0) {
            const baseLabel = state.lang === 'cn' ? '基础' : 'Base';
            html += `<div class="rt-row" style="color:#ffd700"><span>+${r.base}</span> <span style="color:#888;">[${itemName} ${baseLabel}]</span></div>`;
        }
        
        // Track for formula
        let bonusTotal = 0;
        let multTotal = 0;
        let finalMultTotal = 1;
        
        // Process logs - show each effect clearly
        const sortedLogs = [...r.logs].sort((a, b) => (a.order || 0) - (b.order || 0));

        sortedLogs.forEach(l => { 
            // Skip system markers
            if (l.srcId === 'System') return;
            if (l.type === 'rule') return;
            if (l.type === 'cond' && l.val === 'Strong Beat') return;
            
            // Get source name
            let srcName = '';
            let effectDesc = '';
            
            if (l.srcId === 'Self' || l.srcId === 'Self Condition') {
                srcName = itemName;
                // Extract effect type from val
                if (l.val.includes('Strong')) effectDesc = state.lang === 'cn' ? '强拍加成' : 'Strong Beat';
                else if (l.val.includes('Gap')) effectDesc = state.lang === 'cn' ? '间隔加成' : 'Gap Bonus';
                else if (l.val.includes('Sync')) effectDesc = state.lang === 'cn' ? '同步加成' : 'Sync Bonus';
                else if (l.val.includes('Atmo')) effectDesc = state.lang === 'cn' ? '空拍加成' : 'Empty Bonus';
                else if (l.val.includes('Pad')) effectDesc = state.lang === 'cn' ? '空拍加成' : 'Empty Bonus';
                else effectDesc = state.lang === 'cn' ? '额外效果' : 'Bonus';
            } else {
                const srcItem = DB.find(i => i.id === l.srcId);
                srcName = srcItem ? srcItem.name[state.lang] : l.srcId;
                effectDesc = '';
            }
            
            // Parse value and display
            const valStr = l.val;
            let displayVal = '';
            let col = '#aaa';
            
            // Extract number from val string
            const numMatch = valStr.match(/[+-]?\d+\.?\d*/);
            if (!numMatch) return;
            const num = parseFloat(numMatch[0]);
            if (isNaN(num) || num === 0) return;
            
            if (valStr.includes('%')) {
                // Percentage
                if (valStr.includes('-')) {
                    displayVal = `-${Math.abs(num)}%`;
                    col = '#ff5252';
                } else {
                    displayVal = `+${Math.abs(num)}%`;
                    col = '#00e5ff';
                    multTotal += num / 100;
                }
            } else if (valStr.includes('x') || valStr.includes('×')) {
                // Final multiplier
                displayVal = `×${num}`;
                col = '#d500f9';
                finalMultTotal *= num;
            } else {
                // Flat bonus
                if (num > 0) {
                    displayVal = `+${Math.floor(num)}`;
                    col = '#ffd700';
                    bonusTotal += num;
                } else {
                    displayVal = `${Math.floor(num)}`;
                    col = '#ff5252';
                }
            }
            
            // Build display string
            let srcDisplay = srcName;
            if (effectDesc) srcDisplay += ` ${effectDesc}`;
            
            html += `<div class="rt-row" style="color:${col}"><span>${displayVal}</span> <span style="color:#888;">[${srcDisplay}]</span></div>`;
        });
        
        // Build formula and final score for score items
        if (r.record.data.type === 'score') { 
            const final = Math.floor((r.base + r.bonus) * r.mult * r.finalMultiplier); 
            
            // Build clear formula
            let formulaParts = [];
            
            // Base + bonus part
            if (r.bonus > 0) {
                formulaParts.push(`(${r.base}+${Math.floor(r.bonus)})`);
            } else {
                formulaParts.push(`${r.base}`);
            }
            
            // Multiplier part
            const totalMult = r.mult;
            if (totalMult !== 1) {
                formulaParts.push(`×${totalMult.toFixed(2)}`);
            }
            
            // Final multiplier
            if (r.finalMultiplier !== 1) {
                formulaParts.push(`×${r.finalMultiplier.toFixed(1)}`);
            }
            
            let formulaStr = formulaParts.join(' ');
            html += `<div class="rt-formula">${formulaStr} = ${final}</div>`;
            html += `<div class="rt-total">${t.final}: ${final}</div>`; 
        }
        
        // Show buff given count
        if (r.buffsGiven.length > 0) { 
            const buffText = state.lang === 'cn' ? `增益了 ${r.buffsGiven.length} 个道具` : `Buffed ${r.buffsGiven.length} items`;
            html += `<div class="rt-total" style="color:#d500f9; border-top:1px dashed #555;">${buffText}</div>`; 
        }
        
        const rect = r.resEl.getBoundingClientRect(); tip.innerHTML = html; tip.style.display = 'block'; tip.style.left = (rect.right + 10) + 'px'; tip.style.top = rect.top + 'px';
    }

    function showResult(ng1Added, totalScore, isHistoryMode = false) {
        const isWin = totalScore >= config.target; const outcomeEl = document.getElementById('resOutcome');
        const btns = ['nextLevelBtn','finishGameBtn','retryLevelBtn','dieBtn','simCloseBtn']; btns.forEach(id => document.getElementById(id).style.display = 'none');
        const info = document.getElementById('resRewardInfo'); const statusContainer = document.getElementById('campaignStatusContainer'); const t = UI_TEXT[state.lang];

        if (isHistoryMode) { 
            // Simplified preview UI - hide unnecessary elements
            document.getElementById('resTitle').style.display = 'none';
            document.getElementById('campaignStatusContainer').style.display = 'none';
            document.querySelector('#resultModal .modal-content > div:nth-child(4)').style.display = 'none'; // Hide target row
            
            // Tutorial 1-3: Show pass/fail status and allow advancement
            if (state.isTutorial && state.levelIndex <= 2 && state.tutorialPreviewMode) {
                const isWinTut = totalScore >= config.target;
                if (isWinTut) {
                    outcomeEl.innerHTML = `<span style="color:#4caf50">✓</span> ${state.lang === 'cn' ? '达标' : 'TARGET MET'}`;
                    outcomeEl.style.color = "#4caf50";
                    outcomeEl.style.fontSize = '24px';
                    const reward = TUTORIAL_CONFIG[state.levelIndex].reward;
                    info.innerHTML = `<span style="font-size:18px; color:#888;">${state.lang === 'cn' ? '总分' : 'Total'}:</span> <span style="font-size:36px; color:gold; font-weight:bold;">${Math.floor(totalScore)}</span><br><span style="color:#4caf50; font-size:16px;">+${reward}G</span>`;
                    
                    // Show "Next Level" button instead of "Back"
                    document.getElementById('nextLevelBtn').style.display = "block";
                    document.getElementById('nextLevelBtn').innerText = state.lang === 'cn' ? '下一关' : 'NEXT LEVEL';
                    state.pendingReward = reward;
                } else {
                    outcomeEl.innerHTML = `<span style="color:#f44336">✗</span> ${state.lang === 'cn' ? '未达标' : 'NOT MET'}`;
                    outcomeEl.style.color = "#f44336";
                    outcomeEl.style.fontSize = '24px';
                    info.innerHTML = `<span style="font-size:18px; color:#888;">${state.lang === 'cn' ? '总分' : 'Total'}:</span> <span style="font-size:36px; color:gold; font-weight:bold;">${Math.floor(totalScore)}</span><br><span style="color:#888; font-size:14px;">${state.lang === 'cn' ? '调整道具布局后再试' : 'Adjust your layout and try again'}</span>`;
                    document.getElementById('simCloseBtn').style.display = "block";
                }
                state.tutorialPreviewMode = false;
            } else {
                outcomeEl.innerText = state.lang === 'cn' ? '数据分析' : 'DATA ANALYSIS'; 
                outcomeEl.style.color = "#aaa"; 
                outcomeEl.style.fontSize = '24px';
                info.innerHTML = `<span style="font-size:18px; color:#888;">${state.lang === 'cn' ? '总分' : 'Total'}:</span> <span style="font-size:36px; color:gold; font-weight:bold;">${Math.floor(totalScore)}</span>`;
                document.getElementById('simCloseBtn').style.display = "block";
            }
            
            // Tutorial L4: Record simulation score for submit gate
            if (state.isTutorial && state.levelIndex === 3) {
                tutorialState.l4.simScore = totalScore;
            }
            
            renderResultGrid(state.lastResultData); 
            document.getElementById('resultModal').style.display = 'flex'; 
            
            // Tutorial L4: Show score breakdown guide on first simulate
            if (state.isTutorial && state.levelIndex === 3 && !tutorialState.l4.resultGuideShown) {
                tutorialState.l4.resultGuideShown = true;
                setTimeout(() => showSimulateResultGuide(), 500);
            }
            return; 
        }
        
        // Restore visibility for normal result view
        document.getElementById('resTitle').style.display = '';
        document.getElementById('campaignStatusContainer').style.display = '';
        const targetRow = document.querySelector('#resultModal .modal-content > div:nth-child(4)');
        if (targetRow) targetRow.style.display = '';

        let rewardVal = 0;
        if (state.isTutorial) {
            // Tutorial Level 4: Use tier system like standard mode
            if (state.levelIndex === 3) {
                const target = config.target;
                const tier1Threshold = target;
                const tier2Threshold = target * 1.10;
                const tier3Threshold = target * 1.25;
                
                let tier = 0;
                if (totalScore >= tier3Threshold) tier = 3;
                else if (totalScore >= tier2Threshold) tier = 2;
                else if (totalScore >= tier1Threshold) tier = 1;
                
                if (tier > 0) {
                    let tierLabel = tier === 3 ? '★★★' : (tier === 2 ? '★★' : '★');
                    let tierColor = tier === 3 ? '#ff4081' : (tier === 2 ? '#ffd700' : '#76ff03');
                    outcomeEl.innerHTML = `<span style="color:${tierColor}">${tierLabel}</span> ${t.outcomeWin}`;
                    outcomeEl.style.color = "var(--highlight)";
                    
                    rewardVal = TUTORIAL_CONFIG[3].reward || 0;
                    let bonusInfo = `${t.reward}: +${rewardVal}G`;
                    
                    // 3-star: Give Pad (EB6) as bonus (only once)
                    if (tier === 3 && !tutorialState.l4.padGiven) {
                        tutorialState.l4.padGiven = true;
                        addItemToInventory('EB6', 0);
                        const padName = DB.find(i => i.id === 'EB6').name[state.lang];
                        bonusInfo += `, 🎁 ${state.lang === 'cn' ? '稀有道具解锁 1/1' : 'Rare Item 1/1'}: ${padName}`;
                    }
                    
                    info.innerHTML = bonusInfo;
                    document.getElementById('finishGameBtn').style.display = 'block';
                    document.getElementById('finishGameBtn').innerText = t.enterGame;
                    document.getElementById('finishGameBtn').onclick = showTutorialComplete;
        } else {
                    outcomeEl.innerText = t.outcomeLose;
                    outcomeEl.style.color = "var(--lose-color)";
                    rewardVal = TUTORIAL_CONFIG[3].failReward || 0;
                    info.innerText = `${t.consolation}: +${rewardVal}G`;
                    document.getElementById('retryLevelBtn').style.display = 'block';
                }
            } else {
                // Tutorial levels 1-3: original logic
                if (isWin) { 
                    rewardVal = TUTORIAL_CONFIG[state.levelIndex].reward; 
                    outcomeEl.innerText = t.outcomeWin; 
                    outcomeEl.style.color = "var(--highlight)"; 
                    info.innerText = `${t.reward}: +${rewardVal}G`; 
                    document.getElementById('nextLevelBtn').style.display = 'block'; 
                } else { 
                    outcomeEl.innerText = t.outcomeLose; 
                    outcomeEl.style.color = "var(--lose-color)"; 
                    rewardVal = 0; 
                    info.innerText = `Try Again`; 
                    document.getElementById('retryLevelBtn').style.display = 'block'; 
                    if(state.levelIndex !== 2) resetTutorialStateForLevel(state.levelIndex); 
                }
            }
        } else {
            // === TIERED PASS SYSTEM ===
            const baseReward = LEVEL_CONFIG[state.levelIndex].reward;
            const target = config.target;
            const tier1Threshold = target;           // 100%
            const tier2Threshold = target * 1.10;    // 110%
            const tier3Threshold = target * 1.25;    // 125%
            
            // Determine tier achieved
            let tier = 0;
            if (totalScore >= tier3Threshold) tier = 3;
            else if (totalScore >= tier2Threshold) tier = 2;
            else if (totalScore >= tier1Threshold) tier = 1;
            
            // Calculate milestone progress FIRST (before displaying)
            let displayMilestone = state.milestoneProgress;
            let rareRewardName = null;
            let milestoneReached = false;
            
            if (tier === 3) {
                displayMilestone++;
                if (displayMilestone >= 2) {
                    milestoneReached = true;
                    rareRewardName = grantMilestoneReward();
                    state.milestoneProgress = 0; // Reset after granting reward
                } else {
                    state.milestoneProgress = displayMilestone;
                }
                config.maxCpu += 2; // +2 CPU bonus
            }
            
            // Progress display (no hearts anymore)
            let dots = ""; for(let i=0; i<LEVEL_CONFIG.length; i++) { let cls = "status-dot"; if(i < state.levelIndex) cls += " done"; if(i === state.levelIndex && tier > 0) cls += " current done"; dots += `<div class="${cls}"></div>`; }
            
            // Milestone progress display - only show for Tier 3 (3-star) pass
            if (tier === 3) {
                const milestoneText = state.lang === 'cn' ? `稀有道具进度: ${displayMilestone}/2` : `Rare Item Progress: ${displayMilestone}/2`;
                statusContainer.innerHTML = `<div class="status-item" style="margin-right:20px;"><span>Progress:</span><div class="status-dots">${dots}</div></div><div class="status-item"><span style="color:#d500f9;">${milestoneText}</span></div>`;
            } else {
                // For tier 1, 2 or fail - just show level progress, no milestone
                statusContainer.innerHTML = `<div class="status-item"><span>Progress:</span><div class="status-dots">${dots}</div></div>`;
            }
            
            if (tier > 0) {
                // === PASSED ===
                let tierLabel = tier === 3 ? '★★★' : (tier === 2 ? '★★' : '★');
                let tierColor = tier === 3 ? '#ff4081' : (tier === 2 ? '#ffd700' : '#76ff03');
                outcomeEl.innerHTML = `<span style="color:${tierColor}">${tierLabel}</span> ${t.outcomeWin}`;
                outcomeEl.style.color = "var(--highlight)";
                
                // Calculate reward based on tier
                if (tier === 1) {
                    rewardVal = Math.floor(baseReward * 0.85);
                    info.innerText = `${t.reward}: +${rewardVal}G`;
                } else if (tier === 2) {
                    rewardVal = baseReward;
                    info.innerText = `${t.reward}: +${rewardVal}G`;
                } else if (tier === 3) {
                    rewardVal = baseReward;
                    let bonusText = `${t.reward}: +${rewardVal}G, +2 CPU`;
                    if (rareRewardName) {
                        bonusText += `, 🎁 ${rareRewardName}`;
                    }
                    info.innerHTML = bonusText;
                }
                
                if (state.levelIndex >= LEVEL_CONFIG.length - 1) document.getElementById('finishGameBtn').style.display = "block"; 
                else document.getElementById('nextLevelBtn').style.display = "block";
            } else {
                // === FAILED - Game Over ===
                outcomeEl.innerText = t.outcomeLose;
                outcomeEl.style.color = "var(--lose-color)";
                rewardVal = 0;
                info.innerText = state.lang === 'cn' ? '挑战失败，必须从第一关重新开始' : 'Failed. You must restart from Level 1.';
                document.getElementById('dieBtn').style.display = "block";
            }
        }
        state.pendingReward = rewardVal;
        const results = state.lastResultData || calculateLogic(); renderResultGrid(results);
        document.getElementById('resTotalScore').innerText = Math.floor(totalScore); document.getElementById('resTargetDisplay').innerText = config.target; document.getElementById('resultModal').style.display = 'flex';
    }
    
    // Show guide overlay on result screen (used after simulate in tutorial L4)
    function showSimulateResultGuide() {
        // Create guide overlay for result screen
        const overlay = document.createElement('div');
        overlay.id = 'resultGuideOverlay';
        overlay.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.7); z-index:10000; display:flex; justify-content:center;';
        
        // Highlight the result track area
        const resTrackArea = document.getElementById('resTrackArea');
        if (resTrackArea) resTrackArea.style.cssText += ';position:relative; z-index:10001; box-shadow: 0 0 30px rgba(255,215,0,0.8);';
        
        // Create guide message - position at top, above the DAW area
        const msg = document.createElement('div');
        msg.className = 'guide-message';
        const resTrackRect = resTrackArea ? resTrackArea.getBoundingClientRect() : { top: 200 };
        msg.style.cssText = `position:fixed; top:${Math.max(20, resTrackRect.top - 180)}px; left:50%; transform:translateX(-50%); z-index:10002;`;
        
        const title = state.lang === 'cn' ? '💡 提示' : '💡 Tip';
        const text = state.lang === 'cn' 
            ? '将鼠标悬停在下方道具上，可以查看每个道具的具体分数和构成来源！' 
            : 'Hover over items below to see detailed score breakdown and sources!';
        const btnText = state.lang === 'cn' ? '知道了' : 'Got it!';
        
        msg.innerHTML = `<h3>${title}</h3><p>${text}</p><button class="guide-btn" onclick="closeSimulateResultGuide()">${btnText}</button>`;
        
        overlay.appendChild(msg);
        document.body.appendChild(overlay);
    }
    
    function closeSimulateResultGuide() {
        const overlay = document.getElementById('resultGuideOverlay');
        if (overlay) overlay.remove();
        
        // Remove highlight from result track area
        const resTrackArea = document.getElementById('resTrackArea');
        if (resTrackArea) resTrackArea.style.boxShadow = '';
    }
    
    function showResultGuide() {
        tutorialState.l4.resultGuideShown = true;
        
        // Create guide overlay for result screen
        const overlay = document.createElement('div');
        overlay.id = 'resultGuideOverlay';
        overlay.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.7); z-index:10000; display:flex; justify-content:center;';
        
        // Highlight the result track area
        const resTrackArea = document.getElementById('resTrackArea');
        if (resTrackArea) resTrackArea.style.cssText += ';position:relative; z-index:10001; box-shadow: 0 0 30px rgba(255,215,0,0.8);';
        
        // Create guide message - position at top, above the DAW area
        const msg = document.createElement('div');
        msg.className = 'guide-message';
        const resTrackRect = resTrackArea ? resTrackArea.getBoundingClientRect() : { top: 200 };
        msg.style.cssText = `position:fixed; top:${Math.max(20, resTrackRect.top - 180)}px; left:50%; transform:translateX(-50%); z-index:10002;`;
        
        const title = state.lang === 'cn' ? '💡 提示' : '💡 Tip';
        const text = state.lang === 'cn' 
            ? '将鼠标悬停在下方道具上，可以查看每个道具的具体分数和构成来源！' 
            : 'Hover over items below to see detailed score breakdown and sources!';
        const btnText = state.lang === 'cn' ? '知道了' : 'Got it!';
        
        msg.innerHTML = `<h3>${title}</h3><p>${text}</p><button class="guide-btn" onclick="closeResultGuide()">${btnText}</button>`;
        
        overlay.appendChild(msg);
        document.body.appendChild(overlay);
    }
    
    function closeResultGuide() {
        const overlay = document.getElementById('resultGuideOverlay');
        if (overlay) overlay.remove();
        
        // Remove highlight from result track area
        const resTrackArea = document.getElementById('resTrackArea');
        if (resTrackArea) resTrackArea.style.boxShadow = '';
    }

    function showTutorialComplete() { document.getElementById('resultModal').style.display = 'none'; document.getElementById('tutorialCompleteModal').style.display = 'flex'; }
    function finishTutorialFlow() { document.getElementById('tutorialCompleteModal').style.display = 'none'; startStandardGame(); }
    
    // Discord Modal Logic
    let pendingAction = null; // 'victory' or 'gameover'
    
    function shouldShowDiscord() {
        // 只要进入正式关，通关或彻底失败都显示
        return !state.isTutorial;
    }
    
    function showVictory() { 
        if (shouldShowDiscord() && !state.discordShown) {
            state.discordShown = true;
            pendingAction = 'victory';
            showDiscordModal();
        } else {
            document.getElementById('victoryModal').style.display = 'flex'; 
        }
    }
    
    function showGameOver() { 
        if (shouldShowDiscord() && !state.discordShown) {
            state.discordShown = true;
            pendingAction = 'gameover';
            showDiscordModal();
        } else {
            document.getElementById('gameOverModal').style.display = 'flex'; 
        }
    }
    
    function showDiscordModal() {
        document.getElementById('discordModal').style.display = 'flex';
    }
    
    function closeDiscordAndContinue() {
        document.getElementById('discordModal').style.display = 'none';
        if (pendingAction === 'victory') {
            document.getElementById('victoryModal').style.display = 'flex';
        } else if (pendingAction === 'gameover') {
            document.getElementById('gameOverModal').style.display = 'flex';
        }
        pendingAction = null;
    }
    function closeResult() { 
        document.getElementById('resultModal').style.display = 'none'; 
    }
    function nextLevel() { updateGold(state.pendingReward); document.getElementById('resultModal').style.display = 'none'; if (state.isTutorial) { startTutorialLevel(state.levelIndex + 1); } else { const next = state.levelIndex + 1; if(next >= LEVEL_CONFIG.length) showVictory(); else applyLevelConfig(next); } }
    function retryLevel() { 
        updateGold(state.pendingReward); 
        document.getElementById('resultModal').style.display = 'none'; 
        if (state.isTutorial) { 
            startTutorialLevel(state.levelIndex, true); // Pass isRetry = true
        } else { 
            updateUI(); 
            rerollShop(); 
        } 
    }
    function sellSelectedItem() { 
        if (!state.selectedInvItem) return; const item = state.selectedInvItem; 
        if(item.id === "NG1" && state.ng1PermanentStacks > 0) { applyNG1Discount(state.ng1PermanentStacks); state.ng1PermanentStacks = 0; } 
        const price = item.boughtPrice === 0 ? 25 : Math.floor(item.boughtPrice * 0.25); 
        updateGold(price); state.inventory = state.inventory.filter(x => x !== item); state.selectedInvItem = null; 
        const itemId = item.data.id; const initialCount = state.placedItems.length; state.placedItems = state.placedItems.filter(p => p.data.id !== itemId); if (state.placedItems.length !== initialCount) { restorePlacedItems(); }
        updateInventoryUI(); 
        checkGuideAction('sell'); // Tutorial guide
        const shop = document.getElementById('shopPanel'); const float = document.createElement('div'); float.innerText = `+${price}G`; float.style.position = 'absolute'; float.style.left = '50%'; float.style.top = '50%'; float.style.color = 'gold'; float.style.fontWeight='bold'; float.style.transform='translate(-50%, -50%)'; float.style.pointerEvents='none'; shop.appendChild(float); setTimeout(()=>float.remove(), 1000);
    }
    function applyNG1Discount(count) { const minDisc = 0.05 * count; const maxDisc = 0.10 * count; alert(`NG1 Burst! ${count} stacks consumed!`); state.currentShopItems.forEach(item => { if(!item.sold) { let extra = minDisc + Math.random() * (maxDisc - minDisc); const minPrice = Math.floor(item.data.price * 0.1); let newPrice = Math.floor(item.price * (1 - extra)); if (newPrice < minPrice) newPrice = minPrice; item.price = newPrice; item.isDiscount = true; item.discountPercent += Math.round(extra * 100); } }); renderShopFromState(); }
    
    function buyCpu() { 
        if (state.isTutorial && state.levelIndex === 2) { 
            if (state.gold >= 30 && !state.tutorialCpuBought) { 
                updateGold(-30, 'btnBuyCpu'); config.maxCpu++; state.tutorialCpuBought = true; tutorialState.l3.cpuBought = true; 
                updateUI(); updateCPU(); 
                checkGuideAction('cpuBuy'); // Tutorial guide
            } else if (state.gold < 30) { alert(state.lang === 'cn' ? "金币不足" : "Not enough gold"); } 
            return; 
        }
        if (state.isTutorial && state.levelIndex === 3) { tutorialState.l4.cpuCount++; }
        const cost = 30 + (Math.min(state.cpuPurchasedRound, 2) * state.roundBase); 
        if(state.gold >= cost) { 
            updateGold(-cost, 'btnBuyCpu'); config.maxCpu++; state.cpuPurchasedRound++; updateUI(); updateCPU();
            checkGuideAction('cpuBuy'); // Tutorial guide
        } else { alert(state.lang === 'cn' ? "金币不足" : "Not enough gold"); } 
    }
    
    function rerollShop() { 
        if(state.isPlaying) return; 
        const isManual = (event && event.target && event.target.id === 'btnReroll'); if (isManual) { if(state.gold < 10) { alert("No Gold"); return; } updateGold(-10); } 
        state.currentShopItems = []; let candidates = DB.filter(i => state.poolIds.includes(i.id) && !state.inventory.some(inv => inv.id === i.id)); 
        for(let i=0; i<4; i++) { if(candidates.length === 0) break; const rand = Math.random(); let rarityTarget = 1; if (rand > 0.6) rarityTarget = 2; if (rand > 0.9) rarityTarget = 3; let pool = candidates.filter(x => x.rarity === rarityTarget); if (pool.length === 0) pool = candidates; const itemBase = pool[0]; candidates = candidates.filter(x => x.id !== itemBase.id); const variance = Math.floor(Math.random() * 11) - 5; let finalPrice = itemBase.price + variance; const entryRound = state.poolEntryTimes[itemBase.id] || 0; const roundsInPool = state.levelIndex - entryRound; const discountChance = Math.min(0.5, 0.2 + (roundsInPool * 0.1)); let isDiscount = Math.random() < discountChance; let discountPercent = 0; if(isDiscount) { const maxOff = Math.min(0.5, 0.1 + (roundsInPool * 0.1)); const minOff = 0.1; const actualOff = minOff + Math.random() * (maxOff - minOff); finalPrice = Math.floor(finalPrice * (1 - actualOff)); discountPercent = Math.round(actualOff * 100); } state.currentShopItems.push({ data: itemBase, price: finalPrice, isDiscount: isDiscount, discountPercent: discountPercent, sold: false }); } renderShopFromState(); 
    }
    
    function renderShopFromState() { 
        const list = document.getElementById('shopList'); 
        list.innerHTML = ''; 
        state.currentShopItems.forEach(item => { 
            let d = document.createElement('div'); 
            d.className = 'shop-item'; 
        const owned = state.inventory.some(inv => inv.data.id === item.data.id) || state.placedItems.some(p => p.data.id === item.data.id);
        if (item.data.unique && owned) { d.classList.add('owned-unique'); item.sold = true; }

            d.onclick = () => { 
                if(!state.isPlaying) {
                    showDetail(item.data);
                    // Tutorial L2: clicked shop item
                    if (state.isTutorial && state.levelIndex === 1 && guideState.waitingFor === 'shopItemClick') {
                        advanceGuide();
                    }
                }
            };
            
            // Build HTML with clear buy button at bottom
            let html = `<div class="shop-row-top"><b style="color:${item.data.color}">${item.data.name[state.lang]}</b></div>`;
            html += `<div class="shop-row-btm"><span>CPU: ${item.data.cpu}</span><span>Len: ${item.data.len}</span></div>`;
            if (item.isDiscount) html += `<div class="discount-tag">-${item.discountPercent}%</div>`;
            
            // Price and Buy button row
            html += `<div class="shop-price-row">`;
            html += `<span class="shop-price">${item.price} G</span>`;
            html += `</div>`;
            
            d.innerHTML = html;
            
            // Create buy button
            let btn = document.createElement('button'); 
            btn.className = "btn-buy"; 
            const buyText = state.lang === 'cn' ? '购买' : 'BUY';
            if (item.sold) { 
                btn.disabled = true; 
                btn.innerText = UI_TEXT[state.lang].purchased; 
            } else { 
                btn.innerText = buyText;
                btn.onclick = (e) => { 
                    e.stopPropagation(); 
                    if(state.gold >= item.price) { 
                        updateGold(-item.price, 'goldText'); 
                        addItemToInventory(item.data.id, item.price); 
                        item.sold = true; 
                        if (state.isTutorial && state.levelIndex === 1 && item.data.id === 'EB1') tutorialState.l2.bought = true; 
                        if (state.isTutorial && state.levelIndex === 2 && item.data.id === 'SB1') tutorialState.l3.kickBought = true; 
                        updateInventoryUI(); 
                        renderShopFromState(); 
                    } else { 
                        alert(state.lang === 'cn' ? "金币不足" : "Not enough gold"); 
                    } 
                }; 
            }
            d.querySelector('.shop-price-row').appendChild(btn);
            list.appendChild(d); 
        }); 
    }
    
    function updateRealTimeState() { 
        updateCPU(); 
        const results = calculateLogic(); 
        if (state.isTutorial) { results.forEach(r => { if (r.bonus > 0 || r.buffsGiven.length > 0 || r.buffsReceived.length > 0) { if (state.levelIndex === 1 && r.record.data.id === 'EB1') tutorialState.l2.effectActive = true; if (state.levelIndex === 2 && r.record.data.id === 'SB1') tutorialState.l3.kickEffect = true; } }); }
        
        // All possible glow classes
        const allGlowClasses = ['glowing-score', 'glowing-support', 'glowing-engine', 'glowing-support-buff', 'glowing-support-effect', 'glowing-support-perfect'];
        
        state.placedItems.forEach(p => { 
            const res = results.find(r => r.record === p);
            let targetClass = '';
            
            if (p.data.type === "score") {
                // Score items: glow when triggered (bonus effect activated)
                if (res && res.triggered) targetClass = 'glowing-score';
            } else if (p.data.type === "support") {
                // Support items: refined glow states
                // Check if has buff targets (gave buffs to score items)
                const hasBuffTargets = res && res.buffsGiven && res.buffsGiven.length > 0;
                // Check if triggered own extra effect
                const hasExtraEffect = res && res.triggered;
                
                if (hasBuffTargets && hasExtraEffect) {
                    targetClass = 'glowing-support-perfect'; // Both conditions met
                } else if (hasExtraEffect) {
                    targetClass = 'glowing-support-effect'; // Only extra effect
                } else if (hasBuffTargets) {
                    targetClass = 'glowing-support-buff'; // Only has buff targets
                }
            } else if (p.data.type === "engine") {
                // Engine items: glow when triggered
                if (res && res.triggered) targetClass = 'glowing-engine';
            }
            
            // Apply the correct class, remove all others
            allGlowClasses.forEach(cls => { 
                if (cls === targetClass) { 
                    if (!p.el.classList.contains(cls)) p.el.classList.add(cls); 
                } else { 
                    if (p.el.classList.contains(cls)) p.el.classList.remove(cls); 
                } 
            });
        }); 
    }

    // --- TOOLTIP FIX V25.0: SAFER & CLEANER ---
    async function showDetail(item) { 
        if (state.isTutorial) { if (state.levelIndex === 0) { if (item.id === 'TUT1') tutorialState.l1.aClicked = true; if (item.id === 'TUT2') tutorialState.l1.bClicked = true; } if (state.levelIndex === 1 && item.id === 'EB1') { tutorialState.l2.clicked = true; } if (state.levelIndex === 2 && item.id === 'SB1') { tutorialState.l3.kickClicked = true; } }
        
        // Initialize audio on first item click if not already initialized
        if (!audioInitialized) {
            try { await initAudio(); } catch(e) { console.log('Audio init on click failed:', e); }
        }
        
        // Play item sound on every click
        if (audioInitialized && samplePlayers && samplePlayers.has(item.id)) {
            try { samplePlayers.player(item.id).start(); } catch(e) {}
        }
        
        document.getElementById('detailTitle').innerText = item.name[state.lang]; 
        document.getElementById('detailTitle').style.color = item.color; 
        document.getElementById('detailMeta').innerHTML = `<span>CPU: ${item.cpu}</span><span>${state.lang==='en'?'Len':'长度'}: ${item.len}</span><span>${state.lang==='en'?'Base':'基础'}: ${item.base}</span>`; 
        
        let rawDesc = item.desc[state.lang];
        if (item.id === "NG1") { rawDesc += `<br><span style="color:#ffd700; font-weight:bold;">[${UI_TEXT[state.lang].ng1Charge}: ${state.ng1PermanentStacks}]</span>`; } 

        const container = document.getElementById('detailContent');
        container.innerHTML = ''; 

        // 1. Identify Keywords using regex
        const tokens = rawDesc.split(/(\[.*?\])/g);

        tokens.forEach(token => {
            const cleanToken = token.replace('[', '').replace(']', '');
            // Check if this token matches a defined keyword
            // We search keys in DEFINITIONS[state.lang]
            let matchedKey = null;
            for (const key in DEFINITIONS[state.lang]) {
                if (cleanToken.includes(key)) { // "Strong Beat" matches "Strong Beat"
                    matchedKey = key;
                    break;
                }
            }

            if (matchedKey) {
                const span = document.createElement('span');
                span.className = 'tooltip-ref';
                span.onmouseenter = (e) => showTooltip(e, matchedKey);
                span.onmouseleave = () => hideTooltip();
                
                // Set color based on keyword type (no icons)
                let color = '#fff';
                if (token.includes('Strong Beat') || token.includes('强拍')) color = 'var(--kw-strong)';
                else if (token.includes('Weak Beat') || token.includes('弱拍')) color = 'var(--kw-weak)';
                else if (token.includes('Empty') || token.includes('空拍')) color = 'var(--kw-empty)';
                else if (token.includes('Sync') || token.includes('同步')) color = 'var(--kw-sync)';
                else if (token.includes('Same Track') || token.includes('同轨')) color = 'var(--kw-track)';
                else if (token.includes('Consume') || token.includes('吞噬')) color = 'var(--kw-consume)';
                
                span.style.color = color;
                span.innerText = token;
                container.appendChild(span);
            } else {
                // Regular Text
                const textNode = document.createElement('span');
                textNode.innerHTML = token; 
                container.appendChild(textNode);
            }
        });
    }
    
    // ===========================================
    // === V26.0 PERFORMANCE STAGE SYSTEM ===
    // ===========================================
    
    // Performance Stage configuration (based on image analysis)
    // Image size: 3885 x 2145
    const STAGE_CONFIG = {
        imgWidth: 3885,
        imgHeight: 2145,
        // Computer screen area (where DAW is rendered)
        computer: { x: 1340, y: 1580, w: 1200, h: 420 },
        // Heart center position
        heartCenter: { x: 1942, y: 1050 },
        // Small heart positions (particle endpoints)
        judgeHearts: {
            left: { x: 520, y: 880 },
            center: { x: 1942, y: 470 },
            right: { x: 3360, y: 880 }
        },
        // Particle start point (bottom of heart, where lines connect to computer)
        particleStart: { x: 1942, y: 1400 }
    };
    
    // Performance stage state
    let stageState = {
        active: false,
        currentScore: 0,
        targetScore: 0,
        currentExpression: 'neutral', // 'neutral', 'happy', 'angry'
        expressionCheckInterval: null,
        playbackInterval: null,
        playbackStartTime: 0,
        resultData: null,
        particles: []
    };
    
    // Convert image coordinates to screen percentage
    function imgToScreen(x, y) {
        return {
            x: (x / STAGE_CONFIG.imgWidth) * 100,
            y: (y / STAGE_CONFIG.imgHeight) * 100
        };
    }
    
    // Initialize and show Performance Stage
    function showPerformanceStage() {
        const stage = document.getElementById('performanceStage');
        stage.classList.add('active');
        stageState.active = true;
        stageState.currentScore = 0;
        stageState.targetScore = config.target;
        stageState.currentExpression = 'neutral';
        
        // Position computer screen to match the monitor in the image
        // Based on image analysis: monitor is roughly at bottom 25% center
        const computerScreen = document.getElementById('stageComputerScreen');
        computerScreen.style.left = '35%';
        computerScreen.style.top = '73%';
        computerScreen.style.width = '30%';
        computerScreen.style.height = '18%';
        
        // Update score label
        document.getElementById('heartScoreLabel').innerText = 'Total Groove';
        document.getElementById('heartScoreValue').innerText = '0';
        
        // Reset expression to neutral
        setExpression('neutral');
        
        // Render DAW in computer screen (same style as main DAW)
        renderStageDAW();
        
        // Calculate result data
        stageState.resultData = calculateLogic();
        stageState.resultData.forEach(r => r.stageTriggered = false);
        
        console.log('🎭 Performance Stage opened');
    }
    
    // Set judge expression
    function setExpression(expr) {
        if (expr === stageState.currentExpression) return;
        stageState.currentExpression = expr;
        
        const bgNeutral = document.getElementById('stageBgNeutral');
        const bgHappy = document.getElementById('stageBgHappy');
        const bgAngry = document.getElementById('stageBgAngry');
        
        bgNeutral.classList.toggle('hidden', expr !== 'neutral');
        bgHappy.classList.toggle('hidden', expr !== 'happy');
        bgAngry.classList.toggle('hidden', expr !== 'angry');
        
        console.log(`😊 Expression changed to: ${expr}`);
    }
    
    // Check expression based on current score vs expected score at current time
    function checkExpression(elapsedTime) {
        const progress = elapsedTime / TOTAL_DURATION;
        const expectedScore = stageState.targetScore * progress;
        const ratio = stageState.currentScore / expectedScore;
        
        // ±10% = neutral, <90% = angry, >110% = happy
        if (ratio < 0.9) {
            setExpression('angry');
        } else if (ratio > 1.1) {
            setExpression('happy');
        } else {
            setExpression('neutral');
        }
    }
    
    // Render DAW tracks in computer screen
    function renderStageDAW() {
        const container = document.getElementById('stageDawContainer');
        container.innerHTML = '<div class="stage-playhead" id="stagePlayhead"></div>';
        
        const trackCount = config.activeTracks;
        const trackHeight = 100 / trackCount;
        
        for (let t = 0; t < trackCount; t++) {
            const track = document.createElement('div');
            track.className = 'stage-track';
            track.style.height = trackHeight + '%';
            track.style.top = (t * trackHeight) + '%';
            track.style.position = 'absolute';
            track.style.left = '0';
            track.style.right = '0';
            
            // Add grid cells
            for (let i = 0; i < TICKS; i++) {
                const cell = document.createElement('div');
                cell.className = 'stage-grid-cell';
                if (Math.floor(i / 4) % 2 === 0) cell.classList.add('cell-strong');
                cell.style.left = (i / TICKS * 100) + '%';
                cell.style.width = (100 / TICKS) + '%';
                track.appendChild(cell);
            }
            
            container.appendChild(track);
        }
        
        // Add placed items
        state.placedItems.forEach(item => {
            const el = document.createElement('div');
            el.className = 'stage-placed-item';
            el.style.backgroundColor = item.data.color;
            el.style.left = (item.start / TICKS * 100) + '%';
            el.style.width = (item.data.len / TICKS * 100) + '%';
            el.style.top = (item.track * trackHeight + trackHeight * 0.2) + '%';
            el.style.height = (trackHeight * 0.6) + '%';
            el.innerText = item.data.name[state.lang];
            el.id = 'stage-item-' + item.start + '-' + item.track;
            container.appendChild(el);
        });
    }
    
    // Start performance stage playback
    async function startStagePlayback() {
        if (!stageState.active) return;
        
        await initAudio();
        
        // Pre-calculate total score
        let totalScore = 0;
        stageState.resultData.forEach(r => {
            totalScore += (r.base + r.bonus) * r.mult * r.finalMultiplier;
        });
        
        // Apply tier effects
        const scoreRatio = totalScore / config.target;
        applyItemTierEffects(scoreRatio);
        
        // Schedule audio
        Tone.Transport.cancel();
        Tone.Transport.stop();
        Tone.Transport.position = 0;
        
        // Play BGM
        const bgmPlayer = state.isTutorial ? bgPlayers.tutorial : bgPlayers.standard;
        if (bgmPlayer && bgmPlayer.loaded) {
            bgmPlayer.playbackRate = 1;
            bgmPlayer.volume.value = -8;
            Tone.Transport.schedule((t) => { 
                bgmPlayer.start(t, 0).stop(t + TOTAL_DURATION); 
            }, 0);
        }
        
        // Schedule item sounds
        state.placedItems.forEach(item => {
            const start = item.start * TICK_DURATION;
            const id = item.data.id;
            Tone.Transport.schedule((time) => { 
                if (samplePlayers && samplePlayers.has(id)) {
                    const player = samplePlayers.player(id);
                    player.playbackRate = 1;
                    player.volume.value = -2;
                    player.start(time);
                }
            }, start);
        });
        
        Tone.Transport.start();
        stageState.playbackStartTime = Date.now();
        
        // Start visual update loop
        stageState.playbackInterval = setInterval(() => {
            updateStageVisuals();
        }, 50);
        
        // Start expression check every 3 seconds
        stageState.expressionCheckInterval = setInterval(() => {
            const elapsed = (Date.now() - stageState.playbackStartTime) / 1000;
            checkExpression(elapsed);
        }, 3000);
        
        // End playback after duration
        setTimeout(() => {
            finishStagePlayback();
        }, TOTAL_DURATION * 1000 + 200);
    }
    
    // Update stage visuals during playback
    function updateStageVisuals() {
        if (!stageState.active) return;
        
        const elapsed = (Date.now() - stageState.playbackStartTime) / 1000;
        const progress = Math.min(elapsed / TOTAL_DURATION, 1);
        
        // Update playhead
        const playhead = document.getElementById('stagePlayhead');
        if (playhead) playhead.style.left = (progress * 100) + '%';
        
        // Check for item triggers
        const currentTick = progress * TICKS;
        
        stageState.resultData.forEach((r, idx) => {
            if (r.stageTriggered) return;
            
            const item = r.record;
            if (currentTick >= item.start) {
                r.stageTriggered = true;
                
                // Highlight item with enhanced effect
                const itemEl = document.getElementById('stage-item-' + item.start + '-' + item.track);
                if (itemEl) {
                    itemEl.classList.add('playing-active');
                    setTimeout(() => itemEl.classList.remove('playing-active'), 400);
                    
                    // Show floating text on DAW item
                    const itemScore = Math.floor((r.base + r.bonus) * r.mult * r.finalMultiplier);
                    if (r.record.data.type === 'score' && itemScore > 0) {
                        spawnStageDawFloat(itemEl, '+' + itemScore, 'score');
                    } else if (r.buffsGiven && r.buffsGiven.length > 0) {
                        spawnStageDawFloat(itemEl, 'Buff!', 'buff');
                        // Draw beam connections to buffed items
                        r.buffsGiven.forEach(b => {
                            const targetRes = stageState.resultData[b.targetIdx];
                            if (targetRes) {
                                const targetEl = document.getElementById('stage-item-' + targetRes.record.start + '-' + targetRes.record.track);
                                if (targetEl) {
                                    spawnStageDawBeam(itemEl, targetEl);
                                }
                            }
                        });
                    }
                }
                
                // Calculate score for this item
                const itemScore = Math.floor((r.base + r.bonus) * r.mult * r.finalMultiplier);
                
                if (r.record.data.type === 'score' && itemScore > 0) {
                    // Add to total score
                    stageState.currentScore += itemScore;
                    document.getElementById('heartScoreValue').innerText = Math.floor(stageState.currentScore);
                    
                    // Spawn beam effect
                    spawnScoreParticle(itemScore, item.track);
                    
                    // Pulse heart
                    pulseHeart(itemScore);
                    
                    // Float score text in heart
                    showFloatScore('+' + itemScore, 'score');
                } else if (r.buffsGiven && r.buffsGiven.length > 0) {
                    // Support item - show buff
                    spawnScoreParticle(0, item.track);
                    showFloatScore('Buff!', 'buff');
                }
            }
        });
    }
    
    // Spawn floating text on stage DAW item
    function spawnStageDawFloat(itemEl, text, type) {
        const daw = document.getElementById('stageDawContainer');
        if (!daw) return;
        
        const rect = itemEl.getBoundingClientRect();
        const dawRect = daw.getBoundingClientRect();
        
        const float = document.createElement('div');
        float.className = 'stage-daw-float' + (type === 'buff' ? ' buff' : '');
        float.innerText = text;
        float.style.left = (rect.left - dawRect.left + rect.width / 2) + 'px';
        float.style.top = (rect.top - dawRect.top) + 'px';
        daw.appendChild(float);
        
        setTimeout(() => float.remove(), 800);
    }
    
    // Draw beam connection between items on stage DAW
    function spawnStageDawBeam(fromEl, toEl) {
        const daw = document.getElementById('stageDawContainer');
        if (!daw) return;
        
        const dawRect = daw.getBoundingClientRect();
        const fromRect = fromEl.getBoundingClientRect();
        const toRect = toEl.getBoundingClientRect();
        
        const x1 = fromRect.left - dawRect.left + fromRect.width / 2;
        const y1 = fromRect.top - dawRect.top + fromRect.height / 2;
        const x2 = toRect.left - dawRect.left + toRect.width / 2;
        const y2 = toRect.top - dawRect.top + toRect.height / 2;
        
        const dx = x2 - x1;
        const dy = y2 - y1;
        const len = Math.sqrt(dx*dx + dy*dy);
        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
        
        const beam = document.createElement('div');
        beam.className = 'stage-daw-beam';
        beam.style.left = x1 + 'px';
        beam.style.top = y1 + 'px';
        beam.style.width = len + 'px';
        beam.style.transform = `rotate(${angle}deg)`;
        daw.appendChild(beam);
        
        setTimeout(() => beam.remove(), 600);
    }
    
    // Pulse the heart based on score amount
    // Pulse heart based on score - bigger score = stronger pulse
    function pulseHeart(score) {
        const heart = document.getElementById('stageHeartContainer');
        heart.classList.remove('pulse-tiny', 'pulse-small', 'pulse-medium', 'pulse-large', 'pulse-huge');
        
        // Trigger reflow
        void heart.offsetWidth;
        
        // More granular pulse based on score
        if (score >= 80) {
            heart.classList.add('pulse-huge');
        } else if (score >= 50) {
            heart.classList.add('pulse-large');
        } else if (score >= 30) {
            heart.classList.add('pulse-medium');
        } else if (score >= 15) {
            heart.classList.add('pulse-small');
        } else {
            heart.classList.add('pulse-tiny');
        }
    }
    
    // Show floating score text in heart area
    function showFloatScore(text, type) {
        const heartCenter = imgToScreen(STAGE_CONFIG.heartCenter.x, STAGE_CONFIG.heartCenter.y);
        
        // Random position within heart area
        const offsetX = (Math.random() - 0.5) * 10;
        const offsetY = (Math.random() - 0.5) * 8;
        
        const floatEl = document.createElement('div');
        floatEl.className = 'stage-float-score ' + type;
        floatEl.innerText = text;
        floatEl.style.left = (heartCenter.x + offsetX) + '%';
        floatEl.style.top = (heartCenter.y + offsetY) + '%';
        
        document.getElementById('performanceStage').appendChild(floatEl);
        
        setTimeout(() => floatEl.remove(), 1200);
    }
    
    // Spawn particle effect from computer to judge heart
    // Spawn energy beam/ray from computer to judge heart
    function spawnScoreParticle(score, track) {
        const container = document.getElementById('stageParticleContainer');
        const wrapper = document.getElementById('stageWrapper');
        if (!wrapper) return;
        
        const rect = wrapper.getBoundingClientRect();
        
        // Start from bottom center (heart bottom, where lines converge)
        const startX = rect.width * 0.5;
        const startY = rect.height * 0.62;
        
        // Select target based on track - adjusted positions to match judge hearts in image
        let endX, endY;
        if (track === 0) {
            // Left judge heart - more towards center
            endX = rect.width * 0.22;
            endY = rect.height * 0.40;
        } else if (track === 2) {
            // Right judge heart - more towards center
            endX = rect.width * 0.78;
            endY = rect.height * 0.40;
        } else {
            // Center judge heart - at top
            endX = rect.width * 0.5;
            endY = rect.height * 0.22;
        }
        
        // Control point (heart center area)
        const ctrlX = rect.width * 0.5;
        const ctrlY = rect.height * 0.42;
        
        // Create beam container
        const beam = document.createElement('div');
        beam.className = 'stage-beam';
        container.appendChild(beam);
        
        // Create beam head (bright point)
        const head = document.createElement('div');
        head.className = 'stage-beam-head';
        beam.appendChild(head);
        
        // Trail segments for fading effect
        const trailSegments = [];
        const maxTrailLength = 80; // pixels
        let prevX = startX, prevY = startY;
        
        // Animate beam along bezier curve - 0.5 seconds
        const duration = 500;
        const startTime = Date.now();
        
        const animateBeam = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // Quadratic bezier curve
            const t = progress;
            const x = (1-t)*(1-t)*startX + 2*(1-t)*t*ctrlX + t*t*endX;
            const y = (1-t)*(1-t)*startY + 2*(1-t)*t*ctrlY + t*t*endY;
            
            // Position head
            head.style.left = x + 'px';
            head.style.top = y + 'px';
            
            // Create trail segment
            if (progress > 0.02 && progress < 1) {
                const dx = x - prevX;
                const dy = y - prevY;
                const len = Math.sqrt(dx*dx + dy*dy);
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                
                if (len > 2) {
                    const trail = document.createElement('div');
                    trail.className = 'stage-beam-trail';
                    trail.style.left = prevX + 'px';
                    trail.style.top = prevY + 'px';
                    trail.style.width = len + 'px';
                    trail.style.transform = `rotate(${angle}deg)`;
                    trail.style.opacity = '1';
                    beam.appendChild(trail);
                    trailSegments.push({ el: trail, born: Date.now() });
                }
            }
            
            prevX = x;
            prevY = y;
            
            // Fade out old trail segments (fading tail effect)
            trailSegments.forEach((seg, i) => {
                const age = Date.now() - seg.born;
                const fadeProgress = age / 400; // 0.4s fade
                const opacity = Math.max(0, 1 - fadeProgress);
                const scale = Math.max(0.3, 1 - fadeProgress * 0.7);
                seg.el.style.opacity = opacity;
                seg.el.style.height = (4 * scale) + 'px';
                if (fadeProgress >= 1) {
                    seg.el.remove();
                    trailSegments.splice(i, 1);
                }
            });
            
            if (progress < 1) {
                requestAnimationFrame(animateBeam);
            } else {
                // Arrived at target - remove head immediately
                head.remove();
                
                // Let trail fade out over another 0.5s
                setTimeout(() => {
                    beam.remove();
                }, 500);
            }
        };
        
        requestAnimationFrame(animateBeam);
    }
    
    // Finish stage playback
    function finishStagePlayback() {
        if (stageState.playbackInterval) clearInterval(stageState.playbackInterval);
        if (stageState.expressionCheckInterval) clearInterval(stageState.expressionCheckInterval);
        
        Tone.Transport.stop();
        Object.values(bgPlayers).forEach(p => { if(p) p.stop(); });
        if (samplePlayers) samplePlayers.stopAll();
        
        // Reset item effects
        resetItemEffects();
        
        // Wait a moment then show settlement
        setTimeout(() => {
            hidePerformanceStage();
            showSettlement(stageState.currentScore);
        }, 500);
    }
    
    // Hide performance stage
    function hidePerformanceStage() {
        const stage = document.getElementById('performanceStage');
        stage.classList.remove('active');
        stageState.active = false;
        
        // Clear particles
        document.getElementById('stageParticleContainer').innerHTML = '';
    }
    
    // ===========================================
    // === V26.0 SETTLEMENT SCREEN SYSTEM ===
    // ===========================================
    
    let settlementData = {
        score: 0,
        isWin: false,
        tier: 0,
        reward: 0,
        cpuBonus: 0
    };
    
    // Show settlement screen
    function showSettlement(totalScore) {
        const isWin = totalScore >= config.target;
        
        // Calculate tier
        let tier = 0;
        if (totalScore >= config.target * 1.25) tier = 3;
        else if (totalScore >= config.target * 1.10) tier = 2;
        else if (totalScore >= config.target) tier = 1;
        
        // Calculate rewards based on tier
        let baseReward = 0;
        let bonusReward = 0;
        let cpuBonus = 0;
        let rareItemProgress = 0;
        let rareRewardName = null;
        
        if (state.isTutorial) {
            if (isWin) {
                // Tutorial level 4 (index 3) uses same reward structure as normal levels
                if (state.levelIndex === 3) {
                    const tutorialReward = TUTORIAL_CONFIG[state.levelIndex].reward;
                    if (tier === 1) {
                        baseReward = Math.floor(tutorialReward * 0.85);
                    } else if (tier === 2) {
                        baseReward = Math.floor(tutorialReward * 0.85);
                        bonusReward = Math.floor(tutorialReward * 0.15);
                    } else if (tier === 3) {
                        baseReward = Math.floor(tutorialReward * 0.85);
                        bonusReward = Math.floor(tutorialReward * 0.15);
                        cpuBonus = 2;
                    }
                } else {
                    baseReward = TUTORIAL_CONFIG[state.levelIndex].reward;
                }
            }
        } else {
            const levelBaseReward = LEVEL_CONFIG[state.levelIndex].reward;
            if (tier === 1) {
                baseReward = Math.floor(levelBaseReward * 0.85);
            } else if (tier === 2) {
                baseReward = Math.floor(levelBaseReward * 0.85);
                bonusReward = Math.floor(levelBaseReward * 0.15); // Extra for 2-star
            } else if (tier === 3) {
                baseReward = Math.floor(levelBaseReward * 0.85);
                bonusReward = Math.floor(levelBaseReward * 0.15);
                cpuBonus = 2;
                
                // Milestone progress for 3-star: +1 each time, reset to 0 after reaching 2
                rareItemProgress = state.milestoneProgress + 1;
                if (rareItemProgress >= 2) {
                    rareRewardName = grantMilestoneReward();
                    state.milestoneProgress = 0; // Reset after granting reward
                    rareItemProgress = 0;
                } else {
                    state.milestoneProgress = rareItemProgress; // Update state
                }
            }
        }
        
        const totalReward = baseReward + bonusReward;
        settlementData = { score: totalScore, isWin, tier, reward: totalReward, cpuBonus, rareItemProgress, rareRewardName };
        
        // Set background (blurred stage bg)
        const settleBg = document.getElementById('settlementBg');
        settleBg.style.backgroundImage = `url('bg_${stageState.currentExpression || 'neutral'}.png')`;
        
        // Set stamp
        const stampCircle = document.getElementById('stampCircle');
        const stampScore = document.getElementById('stampScore');
        const stampLabel = document.getElementById('stampLabel');
        
        stampCircle.className = 'stamp-circle ' + (isWin ? 'victory' : 'failed');
        stampScore.innerText = Math.floor(totalScore) + ' / ' + config.target;
        stampLabel.innerText = isWin ? (state.lang === 'cn' ? '通过' : 'VICTORY') : (state.lang === 'cn' ? '失败' : 'FAILED');
        
        // Set stars
        const starsContainer = document.getElementById('settlementStars');
        const stars = starsContainer.querySelectorAll('.settlement-star');
        stars.forEach((star, i) => {
            star.classList.toggle('earned', i < tier);
        });
        
        // === Render DAW track preview with item names ===
        renderSettlementDAW();
        
        // === Render rewards ===
        const rewardsList = document.getElementById('rewardsList');
        rewardsList.innerHTML = '';
        
        // Base gold reward
        if (baseReward > 0) {
            const row = document.createElement('div');
            row.className = 'reward-row';
            row.innerHTML = `<span class="reward-label">${state.lang === 'cn' ? '基础奖励' : 'Base Reward'}</span><span class="reward-value gold">+${baseReward}G</span>`;
            rewardsList.appendChild(row);
        }
        
        // Bonus gold (2-star+)
        if (bonusReward > 0) {
            const row = document.createElement('div');
            row.className = 'reward-row';
            row.innerHTML = `<span class="reward-label">${state.lang === 'cn' ? '★★ 额外奖励' : '★★ Bonus'}</span><span class="reward-value gold">+${bonusReward}G</span>`;
            rewardsList.appendChild(row);
        }
        
        // CPU bonus (3-star)
        if (cpuBonus > 0) {
            const row = document.createElement('div');
            row.className = 'reward-row';
            row.innerHTML = `<span class="reward-label">${state.lang === 'cn' ? '★★★ CPU奖励' : '★★★ CPU Bonus'}</span><span class="reward-value cpu">+${cpuBonus} CPU</span>`;
            rewardsList.appendChild(row);
        }
        
        // Rare item reward
        if (rareRewardName) {
            const row = document.createElement('div');
            row.className = 'reward-row';
            row.innerHTML = `<span class="reward-label">${state.lang === 'cn' ? '稀有道具' : 'Rare Item'}</span><span class="reward-value item">🎁 ${rareRewardName}</span>`;
            rewardsList.appendChild(row);
        }
        
        // No rewards
        if (baseReward === 0 && bonusReward === 0 && cpuBonus === 0) {
            const row = document.createElement('div');
            row.className = 'reward-row';
            row.innerHTML = `<span class="reward-label" style="color:#ff5252;">${state.lang === 'cn' ? '无奖励' : 'No Rewards'}</span>`;
            rewardsList.appendChild(row);
        }
        
        // === Milestone progress (only for 3-star in standard mode) ===
        const milestoneContainer = document.getElementById('milestoneContainer');
        if (!state.isTutorial && tier === 3) {
            milestoneContainer.style.display = 'block';
            const progress = rareRewardName ? 0 : rareItemProgress;
            document.getElementById('milestoneLabel').innerText = state.lang === 'cn' 
                ? `稀有道具进度: ${progress}/2` 
                : `Rare Item Progress: ${progress}/2`;
            document.getElementById('milestoneFill').style.width = (progress * 50) + '%';
        } else {
            milestoneContainer.style.display = 'none';
        }
        
        // Set progress dots
        const progressContainer = document.getElementById('settleProgress');
        progressContainer.innerHTML = '';
        const levelCount = state.isTutorial ? TUTORIAL_CONFIG.length : LEVEL_CONFIG.length;
        for (let i = 0; i < levelCount; i++) {
            const dot = document.createElement('div');
            dot.className = 'progress-dot';
            if (i < state.levelIndex) dot.classList.add('done');
            if (i === state.levelIndex && isWin) dot.classList.add('current', 'done');
            progressContainer.appendChild(dot);
        }
        
        // Set button
        const btn = document.getElementById('settlementNextBtn');
        if (isWin) {
            btn.className = 'settlement-btn next';
            btn.innerText = state.lang === 'cn' ? '继续' : 'NEXT';
        } else {
            btn.className = 'settlement-btn retry';
            btn.innerText = state.lang === 'cn' ? '重试' : 'RETRY';
        }
        
        // Show settlement screen with stamp animation
        document.getElementById('settlementScreen').classList.add('active');
        
        // Play stamp sound
        playStampSound();
        
        // Save result data
        state.lastTotalScore = Math.floor(totalScore);
        state.lastResultData = stageState.resultData;
    }
    
    // Render DAW tracks in settlement screen
    function renderSettlementDAW() {
        const container = document.getElementById('settlementTrackPreview');
        container.innerHTML = '';
        
        const results = stageState.resultData || state.lastResultData || [];
        const trackCount = config.activeTracks;
        
        for (let t = 0; t < trackCount; t++) {
            const row = document.createElement('div');
            row.className = 'settle-daw-row';
            
            // Grid background
            const gridBg = document.createElement('div');
            gridBg.className = 'settle-grid-bg';
            for (let i = 0; i < TICKS; i++) {
                const cell = document.createElement('div');
                cell.className = 'settle-grid-cell';
                gridBg.appendChild(cell);
            }
            row.appendChild(gridBg);
            
            // Items on this track
            const trackItems = results.filter(r => r.record.track === t);
            trackItems.forEach(r => {
                const item = r.record;
                const el = document.createElement('div');
                el.className = 'settle-item';
                el.style.backgroundColor = item.data.color;
                el.style.left = (item.start / TICKS * 100) + '%';
                el.style.width = (item.data.len / TICKS * 100) + '%';
                el.innerText = item.data.name[state.lang]; // Show name instead of score
                
                // Hover to show details (same as other result screens)
                el.onmouseenter = () => showResultTooltip(r);
                el.onmouseleave = () => { document.getElementById('resultTooltip').style.display = 'none'; };
                
                // Store reference for tooltip
                r.resEl = el;
                
                row.appendChild(el);
            });
            
            container.appendChild(row);
        }
    }
    
    // Play stamp sound effect (generated)
    function playStampSound() {
        if (!audioInitialized) return;
        
        try {
            // Create a simple stamp sound using oscillators
            const now = Tone.now();
            
            // Thump sound
            const osc = new Tone.Oscillator(80, 'sine').toDestination();
            osc.volume.value = -6;
            osc.start(now);
            osc.frequency.exponentialRampTo(40, 0.1, now);
            osc.stop(now + 0.15);
            
            // Click sound
            const noise = new Tone.NoiseSynth({
                noise: { type: 'white' },
                envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.01 }
            }).toDestination();
            noise.volume.value = -12;
            noise.triggerAttackRelease('16n', now);
        } catch(e) {
            console.log('Stamp sound error:', e);
        }
    }
    
    // Hide settlement screen
    function hideSettlement() {
        document.getElementById('settlementScreen').classList.remove('active');
    }
    
    // Settlement next button handler
    function settlementNext() {
        hideSettlement();
        
        // Apply rewards
        if (settlementData.reward > 0) {
            updateGold(settlementData.reward);
        }
        if (settlementData.cpuBonus > 0) {
            config.maxCpu += settlementData.cpuBonus;
        }
        
        if (settlementData.isWin) {
            // Progress to next level
            if (state.isTutorial) {
                if (state.levelIndex >= TUTORIAL_CONFIG.length - 1) {
                    showTutorialComplete();
                } else {
                    startTutorialLevel(state.levelIndex + 1);
                }
            } else {
                if (state.levelIndex >= LEVEL_CONFIG.length - 1) {
                    showVictory();
                } else {
                    applyLevelConfig(state.levelIndex + 1);
                }
            }
        } else {
            // Retry or game over
            if (state.isTutorial) {
                startTutorialLevel(state.levelIndex, true);
            } else {
                showGameOver();
            }
        }
        
        updateUI();
    }
</script>
</body>
</html>